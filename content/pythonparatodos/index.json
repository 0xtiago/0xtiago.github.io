[
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula01/",
	"title": "1. Números, Aritmética e Impressão na Tela!",
	"tags": [],
	"description": "",
	"content": " Um pouco sobre Python Um pouco sobre Python Números básicos A função print  ⚠️ Dica de formatação   Uma rápida olhada nas expressões  Operadores aritméticos Utilizando múltiplos operadores Agrupando operações com parênteses  ⚠️ Dica de formatação     Exercícios  Bem-vindo a nossa primeira aula de Python! Vamos falar sobre os diferentes tipos de número em Python, impressão de valores e execução de aritmética simples. Também vamos discutir brevemente o conceito de expressões.\nUm pouco sobre Python A primeira versão do Python foi lançada há 30 anos em 1990. Desde então, a linguagem passou por uma grande quantidade de mudanças e se tornou uma das linguagens de programação mais populares do mundo.\nUm dos principais pontos fortes do Python é a legibilidade de seu código, o que o torna extremamente acessível. Frequentemente, o código Python é lido exatamente como o inglês. Python também é extremamente flexível e pode ser encontrado em uma ampla variedade de setores, desde aprendizado de máquina até desenvolvimento web.\nNo momento em que este artigo foi escrito, havia dois principais padrões Python em uso ativo.\nPrimeiro, temos o Python 2.7, que é a versão mais atual do Python 2. O Python 2 tecnicamente atingiu o fim de sua vida útil e não receberá mais atualizações adicionais, mas ainda há uma grande quantidade de código do Python 2 por aí!\nA nova versão do Python é o Python 3, com a versão mais atual sendo o Python 3.9. O Python 3 foi criado para ser um substituto do Python 2 e apresenta uma série de melhorias junto com algumas mudanças significativas de sintaxe. O código escrito em Python 2 pode não ser compatível com Python 3 e, mesmo que o código seja executado, podemos ter um comportamento inesperado.\nAo longo desta série, trabalharemos com Python 3.\nNúmeros básicos Em Python, temos várias maneiras diferentes de representar números, as mais comuns são inteiros e números de ponto flutuante - também conhecidos como \u0026ldquo;números quebrados\u0026rdquo;\u0026hellip;rsrs\nInteiros e flutuantes são tipos numéricos básicos em Python. Os inteiros são usados para representar números inteiros e os floats são usados para números reais com algum componente decimal. Por exemplo, usaríamos um inteiro para o número 3, mas um float para 3.141.\nCriar um número inteiro em Python é muito simples: só precisamos escrever um número inteiro (também conhecido como número inteiro). Por exemplo, podemos criar um número inteiro com o valor 4 assim:\n4 Podemos também escrever números negativos inteiros, colocando um - antes do número:\n6 Floats são criados da mesma forma, porém eles possuem casas decimais. Em outras palavras, há algo depois do ponto, mesmo que isto seja um 0.\nTodos os números abaixo são considerados floats:\n4.0 -156.9 2.842 Porém, não sei se você tentou executar algum destes códigos, nada acontece. Precisamos fazer algo para que eles sejam exibidos.\nA função print O Python possui uma função nativa que exibe informações para nós na tela. Esta função seja chama print.\nVamos cobrir as funções com muitos detalhes ao longo desta série, mas por enquanto você pode pensar nas funções como pacotes de código que podemos executar para realizar alguma ação específica.\nAlguém gentilmente escreveu o código (bastante complicado) que nos permite imprimir coisas no console, e eles o agruparam em uma função chamada print. Podemos executar esta função para realizar a ação de impressão.\nO processo de execução de uma função como essa costuma ser referenciado de “chamada” de uma função.\nEm vez de \u0026ldquo;chamar\u0026rdquo;, alguns dizem \u0026ldquo;rodando\u0026rdquo; ou \u0026ldquo;executando\u0026rdquo; uma função. Todos eles significam a mesma coisa!\nVamos chamar a função de impressão (print) para imprimir o valor 4 no console:\nprint(4) Podemos utilizar esta função múltiplas vezes se nós quisermos, e os valores serão impressos na tela conforme a função print é chamada:\nprint(4.0) print(-156.9) print(2.842) Primeiro nós imprimimos 4, depois em uma linha separada temos -156.9, e finalmente 2.842 na última linha. Como você pode ver , não precisamos de nada especial para imprimir qualquer uma das linhas.\n⚠️ Dica de formatação Sempre que chamarmos uma função, recomenda-se que os parênteses devem sem escritos logo após o nome da função. Por exemplo:\nprint(4) E não desta forma.\nprint (4) Isso não vai afetar a forma como o código funciona - Python não se importa se colocarmos espaços aqui - é apenas considerado um estilo ruim, e desenvolver um bom estilo de codificação é muito importante. Um bom estilo ajudará a tornar seu código mais legível, o que é uma das métricas mais importantes a se considerar quando se trata de escrever código.\nUma rápida olhada nas expressões Antes de passarmos para a próxima seção, precisamos apresentar uma nova palavra: expressão.\nSe algo em nosso código for avaliado como um valor, é uma expressão. Tenha paciência, isso vai fazer muito mais sentido em um momento.\nPor acaso, cada pedaço de código que escrevemos até agora é uma expressão e existem muitos tipos diferentes de expressão em Python.\nPor exemplo, todos os inteiros que escrevemos são expressões. Quando o Python vê cada número inteiro, ele pode usar o valor que eles representam.\nTambém estamos prestes a ver algumas operações aritméticas simples, como 5 + 7, e essas operações também são expressões. No caso de 5 + 7, quando Python vê isso, ele avalia a expressão para outro número inteiro: 12.\nQuando escrevemos print(), esse também é um tipo de expressão chamada expressão de chamada de função.\nIsso significa que print() tem um valor?\nSim, é verdade, e falaremos muito mais sobre isso quando chegarmos às funções mais adiante.\nVejamos os operadores aritméticos e começaremos a ver por que esse conceito de expressão é importante.\nOperadores aritméticos Uma das coisas que fazemos o tempo todo em Python (e programação em geral) é aritmética básica. Conseguimos isso principalmente por meio do uso de símbolos de operador como +, -, /, etc.\nPor exemplo, se quisermos somar dois números, podemos colocar o operador + entre esses dois números:\n1 + 2 3.4 + 11 8 + 4.0 Quando usamos um operador como este, estamos escrevendo uma expressão. Então, quando escrevemos 1 + 2, Python avalia isso e obtemos um inteiro com o valor 3.\nÉ importante ter isso em mente, porque afeta nossa saída quando usamos algo como print. Se tentarmos imprimir algo assim:\nprint(1+2) O Python não irá imprimir a operação, porque no momento em que print é executado, a operação 1+2 já havia sido calculada, e obtido o valor inteiro 3.\nVamos ver alguns exemplos:\nprint(1 + 2) print(3.4 + 11) print(8 + 4.0) Se você executou o código acima, deve ter notado algo interessante. Em vez de obter 3, 14.4 e 12 impressos na tela, o resultado final foi 12.0.\nIsso ocorre porque se qualquer um dos operandos para + for um float, a expressão será avaliada como um float. O mesmo é verdade para vários dos outros operadores, incluindo - e * (que é usado para multiplicação).\nEsses dois operadores funcionam exatamente da mesma maneira que +, então não precisamos falar sobre eles em muitos detalhes, mas aqui estão alguns exemplos:\nprint(7 - 5) print(5 - 11.0) print(-4 - 9) print(4 * 7) print(2 * 29.0) print(8.2 * 34) A divisão é executada usando o operador /, mas ao executar a divisão, o resultado é sempre um float. Não importa se ambos os números são inteiros ou se o resultado normalmente seria um número inteiro. Você pode ver isso executando o código abaixo:\nprint(5 / 6.5) print(20 / 2) print(5.5 / 0.5) Utilizando múltiplos operadores Às vezes, precisamos realizar cálculos mais complicados, e isso pode envolver o uso de vários operadores. Isso é totalmente normal em Python, e podemos encadear quantos desses operadores aritméticos quisermos. Apenas certifique-se de que as coisas não estejam ficando difíceis de ler. Isso não é bom:\n5 + 4 + 8 + 565 + 454.0 + 9 + 2 + 11 + 3 + 20 + 45 + 67 Podemos também encadear na operação diferentes operações.\n5 * 3 - 6 + 2 / 4 Agrupando operações com parênteses Assim como já pudemos ver em nossas aulas de matemática na escola, utilizamos parênteses para agrupar as operações, determinando assim a ordem de operação. Tudo o que estiver dentro de parênteses será calculado primeiro.\n(4 - 5) * (5 + 3) / 2 Na linha acima, (4 - 5) é calculado primeiro e, em seguida, (5 + 3). A multiplicação é então realizada e, finalmente, a divisão. O resultado é um número inteiro com o valor -4.\nPodemos colocar tudo isso entre parênteses ao chamar print se quisermos ver a saída:\n⚠️ Dica de formatação Quando escrevemos operadores binários (operadores com dois operandos) como +, - e *, devemos colocar um espaço em cada lado do operador. Não queremos escrever um código como este:\n1/11+4-3/2 Adicionar espaços torna tudo muito mais fácil de ler:\n1 / 11 + 4 - 3 / 2 No entanto, às vezes pode ser apropriado abrir mão desse espaço para agrupar as operações. Por exemplo, assim:\n1/11 + 4 - 3/2 Agrupar as operações dessa forma ajuda a lembrar os leitores da ordem das operações, deixando claro que não estamos lidando com algo como 1 / (11 + 4).\nExercícios Agora que já lemos o material desta aula, aqui estão alguns exercícios para que você possa praticar:\n  Imprima sua idade no console.\n  Calcule e imprima o número de dias, semanas e meses em 27 anos. Não se preocupe com anos bissextos!\n  Calcule e imprima a área de um círculo com um raio de 5 unidades. Você pode ser tão preciso quanto quiser com o valor de pi.\n  Como parte deste exercício, você pode querer ver quais outros operadores estão disponíveis para nós em Python.\n"
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula02/",
	"title": "2. Strings, Variáveis, e obtendo entrada de dados",
	"tags": [],
	"description": "",
	"content": " Noções básicas de strings (texto) Variáveis: dando nome aos bois!  Lendo valores das variaveis   Obtendo valores do usuário Exercícios  Nesta aula vamos falar sobre como usar strings, obter a entrada do usuário e nomear valores em nossos programas usando variáveis.\nSe você perdeu a aula 1, recomendo dar uma olhada, caso não se sinta confortável com algum dos itens a seguir:\n Inteiros Floats Operadores aritméticos simples (+ , -, / e *) A função print O que são expressões  Noções básicas de strings (texto) Strings em Python são sequências ordenadas de zero ou mais caracteres e podemos usá-las para representar um conjunto de símbolos. Podem ser palavras, frases inteiras ou sequências aleatórias de letras, números e pontuação.\nPara criar uma string, só precisamos colocar algumas séries de caracteres entre aspas:\n\u0026#34;Isso é uma string!\u0026#34; Podemos utilizar aspas duplas ou simples. Para o Python tanto faz! E não há razão específica para utilizar um ou o outo.\n\u0026#39;Isso também é uma string válida\u0026#39; ⚠️ Porém não podemos começar nosso texto um tipo de aspas e terminar com outra.\n\u0026#34;Isto não é uma string válida\u0026#39; Imprimir strings (texto) funciona exatamente como utilizamos com números. Nós apenas precisamos passar o valor para a função print:\nprint(\u0026#34;Olá mundo!\u0026#34;) Variáveis: dando nome aos bois! Uma ferramenta vital que estamos perdendo no momento é uma forma de nos referirmos aos valores que calculamos. Lembre-se de que podemos escrever expressões como 45 + 56, e o Python faz esse cálculo, embora não tenhamos imprimido nada no console. A questão é: como nos referimos ao resultado dessa expressão?\nAcontece que podemos nomear valores em Python usando uma operação de atribuição. A sintaxe para vincular um valor a um nome é relativamente simples. Precisamos apenas escrever o nome que queremos usar, um símbolo = e a expressão ou valor que será atribuído a este nome. Este nome é denominado variável.\nAqui estão alguns exemplos:\nnome = \u0026#34;Sócrates\u0026#34; idade = 28 Os nomes de variáveis que escolhemos dependem inteiramente de nós, mas existem algumas regras que precisamos ter em mente:\n Os nomes das variáveis podem incluir letras, números e caracteres de sublinhado (_). Os nomes das variáveis não podem começar com um número, embora seja permitido começar com um sublinhado. Os nomes das variáveis diferenciam maiúsculas de minúsculas.  Essas limitações significam que todos os seguintes nomes de variáveis são inválidos:\n1st_value nome-sobrenome joaquim\u0026#39;s_age exemplo de variavel   1st_value não é permitido porque começa com um número.\n  nome-sobrenome contém um hífen (-), que não é permitido.\n  joaquim's_age não é permitido porque possui um apóstrofo.\n  exemplo de variavel possui espaços, o que também não é permitido.\n  Essas regras fazem muito sentido. Por exemplo, se os números fossem permitidos como o primeiro caractere de um nome de variável, poderíamos usar nomes de caractere único como 4. No entanto, também é assim que criamos um número inteiro e pode levar a confusão.\nDa mesma forma, o sobre-nome contém um caractere -, que entra em conflito com o operador - para subtração, e joaquim's_age tem um problema semelhante com o ', que é usado para definir strings.\nUm nome de variável válido que pode surpreendê-lo é _. Este é um caso de uso especial que abordaremos posteriormente na série.\nSe quisermos definir nomes de variáveis com várias palavras, podemos separar essas palavras com um sublinhado, assim:\nnome = \u0026#34;Leonel\u0026#34; sobrenome = \u0026#34;Messi\u0026#34; Lendo valores das variaveis Agora que sabemos como vincular valores a nomes, a próxima etapa é aprender como recuperar esses valores de nossas variáveis. A boa notícia é que isso é extremamente simples. Tudo o que temos a fazer é escrever o nome da variável onde queremos usar o valor.\nPor exemplo, podemos escrever algo assim:\nvalor_hora = 20.00 horas_trabalhadas = 40 print(valor_hora * horas_trabalhadas) Aqui, definimos duas variáveis valor_hora, que é um float, e horas_trabalhadas, que é um número inteiro. Em seguida, nos referimos aos valores e os usamos como operandos para o operador *.\nSe executarmos o código acima, veremos 800.00 impresso na tela. Lembre-se de que multiplicar qualquer número por um float resulta em um float.\nPor acaso, referir-se a um nome de variável é outro tipo de expressão. Quando escrevemos um nome de variável em qualquer lugar de nosso código, ele é avaliado como o valor que associamos a esse nome.\nObtendo valores do usuário Até agora, fornecemos todos os valores em nosso código Python, mas às vezes precisamos obter valores do usuário. Por exemplo, talvez queiramos saber o nome e a idade do usuário.\nFelizmente, não precisamos implementar algo assim do zero, porque o Python vem com outra função para fazer exatamente esse trabalho. Esta função é chamada de input.\nChamamos input exatamente da mesma maneira que print, só precisamos escrever o nome da função e colocar os parênteses de abertura e fechamento logo após:\ninput() Se você executar o código acima, não verá nada no console, mas se olhar o botão “Run” no repl.it, verá que diz “Stop”. Isso significa que o programa ainda está em execução. Você também descobrirá que pode digitar no console.\nSe você pressionar Enter, o programa será encerrado. Isso ocorre porque quando você pressiona enter, a função de entrada vai parar de aceitar a entrada do usuário. Como não temos nenhum outro código em nosso programa, Python então fica sem código para executar e termina o programa.\nEmbora possamos chamar a entrada de dados apenas escrevendo input(), normalmente vamos fornecer algum tipo de prompt (texto), para que o usuário saiba o que queremos deles. Seu primeiro instinto pode ser fazer algo assim:\nprint(\u0026#34;Qual o seu nome?: \u0026#34;) input() Isso certamente funcionará, mas a entrada é realmente capaz de fornecer seu próprio texto. Precisamos apenas escrever o texto desejado entre parênteses quando chamamos a função:\ninput(\u0026#34;Qual o seu nome?: \u0026#34;) A última peça do quebra-cabeça é armazenar esse valor em algum lugar. Lembre-se de que as chamadas de função são expressões e, portanto, elas geram algum valor. A função input é avaliada como uma string que contém tudo o que o usuário escreveu em resposta ao prompt. Podemos, portanto, atribuir esta string a uma variável se quisermos, assim:\nnome = input(\u0026#34;Qual o seu nome? \u0026#34;) Se você digitar Manoel, a variável nome terá gravado em memória o nome \u0026quot;Manoel\u0026quot; como uma string.\nExercícios Agora que sabemos como usar strings, variáveis e a função de entrada (input), é hora de praticar alguns exercícios.\n Pergunte ao usuário o nome e a idade, atribua esses valores a duas variáveis e, em seguida, imprima-os. Investigue o que acontece quando você tenta atribuir um valor a uma variável que você já definiu. Tente imprimir a variável antes e depois de reutilizar o nome. Abaixo, você encontrará alguns códigos com vários erros. Tente percorrer o programa linha por linha e corrigir os problemas no código. Recomendo que você tente executar o programa enquanto está trabalhando nele, pois ler as mensagens de erro é uma ótima prática para depurar seus próprios programas.  valor_hora = input(\u0026#34;Digite o valor da sua hora de trabalho: \u0026#39;) prnt(\u0026#34;Valor hora: \u0026#34;) print(valorhora) print(\u0026#34;Horas trabalhadas: \u0026#34;) print(horas_trabalhadas) horas_trabalhadas = input(\u0026#34;Quantas horas você trabalhou esta semana? \u0026#34;) "
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/",
	"title": "Basicão",
	"tags": [],
	"description": "",
	"content": "Capítulo 1 Basicão Vamos começar a amolar o facão!\n"
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Python para todos Use a força Código é poder, e aprender a programar lhe dará poder, e mudará a história da sua vida.\nAlém disso, quanto mais você entende o código, mais entende o impacto que a tecnologia têm na vida das pessoas.\nPouco importa se esses impactos são intencionais ou não. Quando você constrói uma plataforma que uma parte significativa da sociedade usa para comunicação, por exemplo, seu código tem impacto direto na própria sociedade. Quando você escreve um código que ajuda a determinar quem obtém um empréstimo, você influencia quem pode comprar uma casa.\nUse a força, mude sua história e a vida das pessoas na comunidade que você faz parte.\n"
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula07/",
	"title": "7. Laços/Loops com While",
	"tags": [],
	"description": "",
	"content": " Loops infinitos A palavra continue Usando else com loops Exercícios  Na último capítulo, demos uma olhada nos loops for como um meio de reduzir a repetição de código. Os loops for são ótimos para dois tipos de ações repetidas:\n  Quando queremos fazer algo para cada item em algum grupo.\n  Quando queremos fazer algo um determinado número de vezes.\n  Existem, no entanto, outros tipos de repetição que podemos querer realizar. Por exemplo, e se quisermos realizar uma ação quantas vezes forem necessárias até que alguma condição seja atendida? E se quisermos realizar alguma ação repetidamente para sempre?\nPara esse tipo de ação repetida, podemos usar um loop while.\nUm loop while é um pouco mais simples do que um loop for. Precisamos apenas usar a palavra-chave while, seguida por alguma condição de teste. Se a condição for avaliada como um valor verdadeiro, o loop executará uma iteração e, em seguida, testará a condição novamente.\nPor exemplo, podemos escrever um loop while que será executado até que o usuário insira um valor igual ou superior a 10.\nnumero_usuario = input(\u0026#34;Por favor digite um número: \u0026#34;) while int(numero_usuario) \u0026lt; 10: print(\u0026#34;Seu número é menor que 10.\u0026#34;) numero_usuario = input(\u0026#34;Por favor escolha outro número: \u0026#34;) print(\u0026#34;Seu número é igual ou maior a 10.\u0026#34;) Primeiro, solicitamos um número inicial antes de iniciar o loop. Precisamos fazer isso, porque nos referimos ao nome numero_usuario como parte da condição do loop while, portanto, se não definirmos esse nome de antemão, obteremos um NameError.\nMesmo se não fosse o caso, ainda não teríamos um valor para numero_usuario, então o que estaríamos verificando?\nDepois que um usuário insere um número, atingimos a linha onde o loop while começa. Verificamos a condição e, se ela for atendida, executaremos o corpo do loop uma vez. No caso acima, o corpo do loop será executado se o usuário inserir 9 ou menos.\nSe terminarmos dentro do corpo do loop, acabaremos imprimindo a mensagem sobre o número ser menor que 10 e, em seguida, pediremos outro número ao usuário. Observe que atribuímos esse novo valor a numero_usuario, o que significa que quando testamos a condição novamente, agora estamos testando um novo valor.\nSe nomearmos essa variável de outra forma, continuaremos verificando o valor original indefinidamente e, claro, nada mudará se o valor permanecer o mesmo. Isso pode nos levar a uma situação difícil, porque o loop vai acabar iterando infinitamente, e não intencionalmente.\nQuando temos um loop while onde estamos verificando um valor como este, certifique-se de que podemos alterar o valor dentro do loop.\nLoops infinitos Às vezes, um loop infinito é o que desejamos e há muitas maneiras de conseguir isso.\nMuito parecido com as instruções condicionais, não precisamos usar operadores de comparação para nossa condição de loop: podemos apenas especificar um valor, e a veracidade desse valor determinará se o loop executa ou não a próxima iteração.\nNa verdade, podemos usar qualquer expressão que quisermos, porque todas as expressões serão avaliadas para algum valor e, se obtivermos um valor, podemos testar seu valor verdadeiro. Podemos usar chamadas de função ou operações aritméticas, ou podemos nos referir a variáveis. O céu é o limite.\nQuando queremos especificar um loop infinito, queremos escrever uma expressão que sempre será avaliada como um valor verdadeiro. Um bom exemplo é o valor booleano True, que sempre será avaliado como True se testarmos seu valor verdade.\nNão recomendo que você execute este código, mas poderíamos escrever algo assim:\nwhile True: print(\u0026#34;Olá meu amigo!\u0026#34;) O que vai acontecer aqui é que o Python executará muito rapidamente muitas iterações desse loop e terminaremos com um fluxo constante de \u0026quot;Olá me amigo!\u0026quot; impresso no console.\nQuando escrevemos um loop explicitamente infinito como este, geralmente é importante que tenhamos alguma maneira de interrompê-lo, e isso é mais frequentemente realizado com algum tipo de instrução condicional em combinação com break.\nComo exemplo, vamos criar o esqueleto de um menu de texto simples. Teremos algumas opções que o usuário pode selecionar e uma dessas opções fechará o menu. Essa opção será a string \u0026quot;q\u0026quot;.\nwhile True: opcao = input(\u0026#34;Por favor, digite \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, ou \u0026#39;c\u0026#39;, ou digite \u0026#39;s\u0026#39; para sair: \u0026#34;) if opcao == \u0026#34;a\u0026#34;: print(\u0026#34;Você selecionou a opção \u0026#39;a\u0026#39;!\u0026#34;) elif opcao == \u0026#34;b\u0026#34;: print(\u0026#34;Você selecionou a opção \u0026#39;b\u0026#39;!\u0026#34;) elif opcao == \u0026#34;c\u0026#34;: print(\u0026#34;Você selecionou a opção \u0026#39;c\u0026#39;!\u0026#34;) elif opcao == \u0026#34;q\u0026#34;: print(\u0026#34;Você selecionou a opção \u0026#39;s\u0026#39;! Saindo do menu!\u0026#34;) break else: print(\u0026#34;Você digitou uma opção inválida\u0026#34;) Podemos imaginar que, em vez de simplesmente imprimir a seleção do usuário, cada uma dessas ramificações executaria algumas ações em nome do usuário e, quando terminarmos, solicitamos outra opção ao usuário.\nSe o usuário inserir uma opção inválida, chegamos até o else e informamos o usuário de seu erro.\nSe o usuário digitar \u0026quot;s\u0026quot;, informamos ao usuário que estamos fechando o menu e, em seguida, usamos uma instrução break para sair do loop.\nObserve que, para este estilo de loop, não precisamos definir nada fora do loop, porque não temos uma condição que dependa de alguma variável.\nDica Se você começar a olhar o código de outras pessoas, poderá ver alguns loops escritos como o abaixo, com 1 como a condição do loop:\nwhile 1: ... algumas ações aqui ... Isso funciona porque 1 é um valor verdadeiro, assim como todos os números diferentes de zero. Embora funcione, eu pessoalmente desaconselho seu uso, pelo mesmo motivo, não o aconselharia a escrever um loop como este:\nwhile \u0026#34;carneirinho\u0026#34;: Tanto 1 quanto \u0026quot;carneirinho\u0026quot; são valores verdadeiros, mas são muito menos explícitos do que apenas escrever enquanto True. Ser explícito e tornar nosso código o mais fácil de ler possível é mais importante do que economizar ao escrever três caracteres.\nA palavra continue Já usamos a instrução break várias vezes, mas não é nossa única opção para controlar o fluxo de nossos loops. Outra opção que temos disponível é a palavra-chave continue.\nEnquanto break nos permite sair de um loop, continue nos permite pular o restante do corpo do loop para a iteração atual.\nPor exemplo, vamos criar um loop que imprime apenas números pares:\nfor numero in range(10): if numero % 2 != 0: ## Verifica se o resto da divisão por 2 é diferente de 0. continue print(numero) Para cada iteração do loop, usamos o operador módulo(%) para determinar se o número atual é divisível por 2. Se não for, encontramos esta instrução continue, que nos move imediatamente para a próxima iteração do loop. Isso significa que pulamos o restante do corpo do loop e não imprimimos o número.\nA saída, portanto, será semelhante a esta:\n0 2 4 6 8 Embora este exemplo use uma instrução continue em um loop for, eles também podem ser usados com loops while.\nAs declarações continue geralmente não são tão úteis, mas de vez em quando elas podem realmente ajudar a simplificar o código com condições complexas.\nUsando else com loops Na aula 5, demos uma olhada no else no contexto das declarações condicionais, mas eu disse na época que também podemos usar o else com outras estruturas. loops for e while estão entre essas estruturas.\nA cláusula else no contexto de loops é um pouco estranha e não parece fazer muito sentido. Certamente não é tão intuitivo quanto é com uma instrução if. Acho que vale a pena pensar em outra coisa como uma cláusula \u0026ldquo;sem interrupção\u0026rdquo; quando a usamos com loops.\nO motivo pelo qual digo que é bom pensar em else como significando \u0026ldquo;sem interrupção\u0026rdquo; é porque uma cláusula else anexada a um loop só será executada se uma instrução break não for encontrada durante a execução desse loop.\nPor exemplo, vamos escrever um loop para determinar se um número é primo ou não. Um número primo é um número divisível apenas por ele mesmo e 1. Por exemplo, 2, 3, 5, 7, 11 e 13 são números primos.\nUma maneira de determinar se algo é primo ou não é dividindo-o por cada número que vem antes dele. Se nenhuma dessas divisões produzir um resultado inteiro, sabemos que o número é primo.\nNo entanto, não precisamos verificar todos os números. Se encontrarmos uma divisão que produz um resultado inteiro, sabemos que o número não é primo, então não precisamos verificar mais. Podemos, portanto, quebrar o ciclo.\nSe quebrarmos sempre que descobrirmos que um número não é primo, isso significa que se completarmos o loop e, portanto, não encontrarmos uma instrução break, teremos um número primo. Essas também são as condições para acionar uma cláusula else.\n# Solicite um número ao usuário dividendo = int(input(\u0026#34;Por favor digite um número: \u0026#34;)) # Cria um range de 2 até o número escolhido e guarda em divisor for divisor in range(2, dividendo): # Se o número usuário escolhido for divisível (não restar nada) por algum dos numeros da lista, o número não é primo if dividendo % divisor == 0: print(f\u0026#34;{dividendo}não é primo!\u0026#34;) break else: # Essa linha apenas rodará se nenhum divisor produzir números inteiros print(f\u0026#34;{dividendo}é primo!\u0026#34;) Podemos fazer algo com o loop while também:\n# Solicite um número ao usuário, e configure o divisor inicial em 2. dividendo = int(input(\u0026#34;Por favor digite um número: \u0026#34;)) divisor = 2 # Continue repetindo até que o divisor seja igual ao número que estamos testando while divisor \u0026lt; dividendo: # Se o número for divisivel pelo divisor, quebra o loop if dividendo % divisor == 0: print(f\u0026#34;{dividendo}não é primo!\u0026#34;) break # Incrementa o divisor para a próxima iteração divisor = divisor + 1 else: # Essa linha apenas rodará se nenhum divisor produzir números inteiros print(f\u0026#34;{dividendo}é primo!\u0026#34;) Existem maneiras mais sofisticadas de encontrar números primos, mas elas servem muito bem como demonstrações. Se você gostaria de um desafio, veja se pode torná-los mais eficientes.\nExercícios  Escreva um pequeno programa de jogo de adivinhação usando um loop while. O usuário deve ser solicitado a adivinhar um número entre 1 e 100 e você deve dizer se a estimativa foi muito alta ou muito baixa após cada estimativa. O loop deve continuar funcionando até que o usuário adivinhe o número corretamente. Usando um dos exemplos anteriores - ou uma solução inteiramente sua - crie um programa que imprima todos os números primos entre 1 e 100.  "
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula06/",
	"title": "6. Laços/Loops com For",
	"tags": [],
	"description": "",
	"content": " Por que precisamos dos loops? O que é um loop for? Definindo um loop for Declarando uma parada com o break A função range  Usando range em loops for   Importante Exercícios  Neste capítulo vamos falar sobre loops for, que nos permitirão repetir algumas ações uma vez para cada item de uma coleção(ex: lista).\nPor que precisamos dos loops? Vamos utilzar um exemplo anterior, onde definimos uma lista com tuplas para representar filmes de um catálogo.\nfilmes = [ ( \u0026#34;Tropa de Elite 2 - O Inimigo Agora é Outro\u0026#34;, \u0026#34;José Padilha\u0026#34;, 2010 ), ( \u0026#34;Austin Powers 2\u0026#34;, \u0026#34;Jay Roach\u0026#34;, 1999 ), ( \u0026#34;O Auto da Compadecida\u0026#34;, \u0026#34;Guel Arraes\u0026#34;, 2000 )] Aqui temos uma lista chamada filmes, que contém várias tuplas. Essas tuplas contêm dados em uma ordem definida: o primeiro elemento em cada tupla é o título do filme; o segundo elemento é o diretor do filme; e o elemento final é o ano de lançamento.\nImagine que queremos imprimir o conteúdo desta lista de filmes. Usando nosso conhecimento atual, podemos fazer algo assim:\nfilme = filmes[0] print(f\u0026#34;{filme[0]}({filme[2]}), por {filme[1]}\u0026#34;) filme = filmes[1] print(f\u0026#34;{filme[0]}({filme[2]}), por {filme[1]}\u0026#34;) filme = filmes[2] print(f\u0026#34;{filme[0]}({filme[2]}), por {filme[1]}\u0026#34;) O que imprimirá na tela da seguinte forma:\nTropa de Elite 2 - O Inimigo Agora é Outro (2010), por José Padilha Austin Powers 2 (1999), por Jay Roach O Auto da Compadecida (2000), por Guel Arraes Se quiséssemos ser um pouco mais sucintos, poderíamos deixar de lado as variáveis do filme e encadear várias expressões de assinatura:\nprint(f\u0026#34;{filmes[0][0]}({filmes[0][2]}), por {filmes[0][1]}\u0026#34;) print(f\u0026#34;{filmes[1][0]}({filmes[1][2]}), por {filmes[1][1]}\u0026#34;) print(f\u0026#34;{filmes[2][0]}({filmes[2][2]}), por {filmes[2][1]}\u0026#34;) Existem alguns problemas com o tipo de código que escrevemos acima. Em primeiro lugar, temos muitos códigos duplicados, o que torna este programa difícil de manter. Imagine se quiséssemos alterar a saída do programa deste:\nO Auto da Compadecida (2000), por Guel Arraes Para este:\nO Auto da Compadecida (2000) - Guel Arraes Temos que fazer essa mudança em 3 lugares diferentes. Mesmo com esse pequeno número de filmes, é muito fácil se perder um ou cometer um pequeno erro na formatação, o que pode levar a diferenças não intencionais na saída de filme para filme.\nAgora imagine que temos 50 filmes. Ou 1.000 filmes. Nosso problema de manutenção não só ficou muito pior, como até escrever isso pela primeira vez será um pesadelo.\nNosso código também é muito frágil. Não podemos contabilizar nenhuma alteração na lista de filmes e precisamos saber com antecedência quantos filmes existem, para que possamos escrever um número apropriado de chamadas da função print.\nComo esse tipo de duplicação de código apresenta grandes desafios, as linguagens de programação modernas nos fornecem muitas ferramentas para remover esse tipo de duplicação. Neste caso particular, a ferramenta que queremos é um loop for.\nO que é um loop for? Um loop for em Python é um meio de realizar algum conjunto de operações para cada item em uma coleção ou, mais geralmente, um iterável. Em um sentido muito vago, podemos pensar em um iterável como algo que é capaz de nos dar valores um de cada vez, como uma lista, onde você pode percorrê-la.\nNo caso de nosso exemplo de biblioteca de filmes, um loop for nos permitirá obter itens da lista de filmes um de cada vez e executar uma ação (ou série de ações) para cada filme. Nesse caso, essa ação é imprimir o filme em algum formato específico.\nAqui está um exemplo concreto de um loop para imprimir cada filme na lista de filmes no formato que usamos anteriormente:\nfilmes = [ ( \u0026#34;Tropa de Elite 2 - O Inimigo Agora é Outro\u0026#34;, \u0026#34;José Padilha\u0026#34;, 2010 ), ( \u0026#34;Austin Powers 2\u0026#34;, \u0026#34;Jay Roach\u0026#34;, 1999 ), ( \u0026#34;O Auto da Compadecida\u0026#34;, \u0026#34;Guel Arraes\u0026#34;, 2000 )] for filme in filmes: print(f\u0026#34;{filme[0]}({filme[2]}), por {filme[1]}\u0026#34;) Como você pode ver, esse tipo de loop pode ser extremamente poderoso. A lista de filmes pode ter 10.000 filmes e conseguimos imprimi-los todos com apenas duas linhas de código.\nDefinindo um loop for A definição do loop começa com a palavra-chave for (para). Esta palavra-chave é o que diz ao Python que queremos definir um loop for.\nLogo depois disso, temos um nome de variável, mas não é um nome que definimos em outro lugar em nosso código. Voltaremos a isso em um momento.\nEm seguida, temos a palavra-chave in (em), seguida pelo iterável (ex: lista) do qual queremos obter valores. Toda esta linha é finalizada com dois pontos.\nIndentado abaixo do bloco está o código que queremos executar para cada item em nosso iterável. Assim como acontece com as instruções condicionais, esse recuo é importante, pois indica qual código está associado ao loop for. Esse bloco recuado às vezes é chamado de corpo do loop.\nOk, então o que está acontecendo com este nome, filme, em nosso exemplo? Na verdade, estamos definindo uma nova variável como parte do loop, e essa variável nos permitirá referir-nos a um determinado valor em nosso iterável.\nQuando executamos um loop for, começamos a iteração sobre o iterável que fornecemos. Isso significa apenas que estamos obtendo valores do iterável um de cada vez.\nQuando obtemos um novo valor de nosso iterável, atribuímos esse nome que definimos como parte do loop e, em seguida, executamos o código no corpo do loop. Assim que terminarmos, pegamos um novo valor do iterável, atribuímos esse novo valor à variável de loop e executamos o corpo do loop novamente com esse novo valor.\nQuando esgotamos os valores, o loop termina e passamos para qualquer código que vier após o loop.\nSe pensarmos sobre isso em termos de nosso exemplo de biblioteca de filmes, definiremos uma variável de loop chamada filme, e o iterável do qual estamos pegando valores é a lista de filmes.\nDurante a primeira iteração (ciclo) do loop, pegamos o primeiro item dos filmes, que é esta tupla:\n( \u0026#34;Tropa de Elite 2 - O Inimigo Agora é Outro\u0026#34;, \u0026#34;José Padilha\u0026#34;, 2010 ) Essa tupla é atribuída ao filme e, em seguida, executamos o código no corpo do loop. Temos apenas uma linha de código no corpo, que se parece com isto:\nprint(f\u0026#34;{filme[0]}({filme[2]}), por {filme[1]}\u0026#34;) Como você pode ver, estamos nos referindo a esta variável filme aqui, portanto, nesta primeira iteração do loop, filme[0] é a string \u0026ldquo;Tropa de Elite 2 - O Inimigo Agora é Outro\u0026quot;; filme[1] é a string, \u0026ldquo;José Padilha\u0026quot;; e filme[2] é o número inteiro, 2010.\nAgora terminamos de executar o código no corpo do loop, então tentamos obter outro valor de filmes. Como ainda temos filmes na lista, Python nos dá a próxima tupla:\n( \u0026#34;Austin Powers 2\u0026#34;, \u0026#34;Jay Roach\u0026#34;, 1999 ) Essa nova tupla é atribuída ao filme, substituindo o valor antigo, e executamos o corpo do loop novamente.\nIsso acontece de novo e de novo até acabar a lista de filmes.\nÉ importante ter em mente que o nome, filme, não é importante do ponto de vista da funcionalidade. Python não está fazendo magicamente a conexão entre os nomes de filme e filmes. Poderíamos fazer qualquer um dos seguintes e funcionaria da mesma forma:\nfor f in filmes: print(f\u0026#34;{f[0]}({f[2]}), por {f[1]}\u0026#34;) for flm in filmes: print(f\u0026#34;{flm[0]}({flm[2]}), por {flm[1]}\u0026#34;) for detalhes_do_filme in filmes: print(f\u0026#34;{detalhes_do_filme[0]}({detalhes_do_filme[2]}), by {detalhes_do_filme[1]}\u0026#34;) É apenas um nome de variável como qualquer outro que possamos definir.\nDeclarando uma parada com o break Às vezes, não queremos iterar em uma coleção inteira ou queremos parar o loop em certas circunstâncias. Nesses casos, podemos usar uma instrução chamada break.\nbreak é geralmente usado em conjunto com uma instrução condicional, porque caso contrário, ele será executado durante a primeira iteração do loop, o que torna o loop basicamente discutível.\nUma maneira comum de usar uma instrução break é evitar operações desnecessárias. Por exemplo, digamos que queremos verificar se um determinado filme está na biblioteca de filmes a que sempre nos referimos.\nfilmes = [ ( \u0026#34;Tropa de Elite 2 - O Inimigo Agora é Outro\u0026#34;, \u0026#34;José Padilha\u0026#34;, 2010 ), ( \u0026#34;Austin Powers 2\u0026#34;, \u0026#34;Jay Roach\u0026#34;, 1999 ), ( \u0026#34;O Auto da Compadecida\u0026#34;, \u0026#34;Guel Arraes\u0026#34;, 2000 )] for filme in filmes: # Verifique se o título do filme é \u0026#34;O Auto da Compadecida\u0026#34; if filme[0] == \u0026#34;O Auto da Compadecida\u0026#34;: # Se o título \u0026#34;O Auto da Compadecida\u0026#34; for encontrado, informe o usuário e pare o loop. print(\u0026#34;\u0026#39;O Auto da Compadecida\u0026#39; está no catálogo!\u0026#34;) break Nesse caso, tudo o que importa é que o filme exista, então, se acabar sendo o primeiro item, não há necessidade de ficarmos checando o resto. Se houver 10.000 filmes, nós potencialmente nos salvamos verificando 9.999 filmes.\nLembre-se de que, para incluir a instrução if dentro do loop for, ela precisa ser indentada com 4 espaços. Portanto, o corpo da instrução if precisa ser indentado com 8 espaços para estar dentro do loope da instrução if.\nIMPORTANTE: Os editores atuais permitem usar o TAB, que é automaticamente formatado para 4 espaços.\nA função range Python tem uma função interna chamada range (intervalo), que é capaz de produzir uma série de inteiros de acordo com algum padrão definido. Por exemplo, podemos querer obter uma série de números começando em 1 e terminando em 100, movendo-se em etapas de 3. Nesse caso, teríamos 1, 4, 7, 10, 13, 16, 19, etc.\nChamamos a função rangeda mesma forma que fazemos para algo como imprimir (print) ou inserir (input), mas o range pode assumir um número variável de valores.\nA maneira mais simples de definir um range é fornecer o valor de parada para o intervalo:\nrange(10) Isso nos dará uma sequência de inteiros começando em zero e indo até, mas não incluindo, o valor de parada. range(10), portanto, nos dará uma sequência como esta:\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9 Como alternativa, podemos fornecer um valor inicial e um valor final. Nesse caso, o valor inicial vem primeiro e esse valor é incluído no intervalo. range(10) é, portanto, o mesmo que escrever range (0, 10).\nDigamos que queremos que nosso intervalo comece em 3 por algum motivo e que vá até, mas não incluindo 10. Definiríamos um intervalo assim:\nrange(3, 10) Que vai retornar os seguintes valores:\n3, 4, 5, 6, 7, 8, 9 Se especificarmos um valor inicial e um valor final, podemos opcionalmente especificar um valor de etapa. Por padrão, esse valor é 1, o que significa que o próximo número na sequência é 1 maior do que o número anterior.\nSe, em vez disso, quiséssemos obter todos os outros números, poderíamos especificar uma etapa de 2. Se quiséssemos a cada três números, especificaríamos uma etapa de 3.\nrange(0, 10, 2) # 0, 2, 4, 6, 8 range(0, 10, 3) # 0, 3, 6, 9 Também podemos especificar um valor de passo negativo, o que significa que retrocedemos do valor inicial ao valor final.\nrange(10, 0, -1) # 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 Tenha cuidado, porque se especificarmos um intervalo onde não podemos ir de um valor para outro, intervalo não vai reclamar: ele apenas nos dará uma sequência vazia. Por exemplo:\nrange(0, 10, -1) Não há como obtermos de 0 a 10 em etapas de -1, portanto, o intervalo não nos dá nada, em vez de uma coleção infinita.\nUma coisa interessante sobre o range é que ele é um tipo lazy (preguiçoso). Isso significa que nosso intervalo não contém, na verdade, todos os valores nesta sequência. Em vez disso, ele apenas descobre qual deve ser o próximo número quando o pedimos.\nIsso significa que se você tentar imprimir um intervalo, não verá todos os valores:\nprint(range(1000)) #range(0, 1000) Tudo o que temos é uma definição para o intervalo que geramos. Esse intervalo começa em 0, vai para 1000 e usa um valor de etapa padrão. Isso torna o intervalo realmente eficiente em termos de memória, porque ele não precisa armazenar uma coleção de potencialmente milhões de números.\nrange é iterável, o que significa que podemos usá-lo em loops for. Também significa que podemos convertê-lo em uma lista ou tupla, se quisermos.\nPodemos fazer isso usando as funções de lista (list) e tupla (tuple), assim como convertemos inteiros, flutuantes e strings usando int, float e str.\nnumeros = list(range(10)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numeros_imutaveis = tuple(range(10)) # (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) Usando range em loops for Uma coisa para a qual o intervalo é realmente útil é executar um loop um determinado número de vezes.\nSe gerarmos um intervalo usando algo como intervalo (10), esse intervalo é capaz de fornecer dez números. Se iterarmos sobre essa coleção, intervalo vai nos dar esses números um de cada vez, e vamos executar o corpo do loop uma vez para cada número.\nfor numero in range(10): print(numero) # 0 # 1 # 2 # ... # 9 Mesmo se não usarmos o intervalo de números gerado, ainda sabemos que obteremos dez iterações do loop.\nPor exemplo, podemos imprimir uma determinada string dez vezes assim:\nfor numero in range(10): print(\u0026#34;Oi mané!\u0026#34;) A saída ficará assim:\nOi mané! Oi mané! Oi mané! Oi mané! Oi mané! Oi mané! Oi mané! Oi mané! Oi mané! Oi mané! Quando escrevemos um loop como este, onde o número que estamos gerando não está sendo usado, é uma convenção comum nomear a variável do loop, _. Este é um sinal claro para os leitores de nosso código de que a variável de loop não está presente em nosso corpo de loop.\nImportante Às vezes, você encontrará loops com _ como a variável de loop. Isso é perfeitamente legal, porque _ é um nome de variável válido e, portanto, Python não reclamará.\nEmbora seja legal, não use _ no lugar de bons nomes descritivos. Ele serve a um propósito específico, que é indicar aos leitores que a variável de loop não está realmente sendo usada no corpo do loop.\nUm bom momento para usar _ como uma variável de loop é em situações como esta:\nfor _ in range(10): print(\u0026#34;Oi mané!\u0026#34;) Aqui, estamos apenas usando o intervalo para garantir um certo número de iterações. Nunca nos referimos aos números que o intervalo está gerando. Essa é uma boa prática e muito útil para os leitores acostumados a essa convenção de nomenclatura.\nNunca devemos usar _ em um loop como o mostrado abaixo:\nfor _ in range(10): print(_) Aqui estamos fazendo referência _ dentro do corpo do loop, o que não é apenas muito feio, mas também está desperdiçando a oportunidade de usar nomes bons e descritivos.\nExercícios   Abaixo está uma lista de tuplas, onde cada tupla contém detalhes sobre um funcionário de uma loja: seu nome, o número de horas trabalhadas na semana passada e sua taxa horária. Imprima o quanto cada funcionário deve receber no final da semana em um formato legível.\nempregados = [ (\u0026#34;João Almeida\u0026#34;, 35, 8.75), (\u0026#34;Adalberto Paiva\u0026#34;, 30, 12.50), (\u0026#34;Cleonice Silva\u0026#34;, 50, 15.50), (\u0026#34;Joaquim Silva\u0026#34;, 20, 7.00) ]   Para os funcionários acima, imprima aqueles que estão ganhando um salário por hora acima da média.\nDica: você pode usar um loop for e duas variáveis para controlar o salário total e o número de funcionários. Em seguida, use as duas variáveis para calcular a média. Por fim, adicione outro loop que percorra a lista de funcionários novamente e imprima apenas aqueles que têm uma remuneração por hora acima da média calculada.\n  "
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula05/",
	"title": "5. Booleanos e Condicionais",
	"tags": [],
	"description": "",
	"content": " Valores verdadeiros Operadores de comparação  Ordem das operações   Condicionais  Valores verdadeiros e condicionais   Exercícios  Antes de examinarmos os condicionais, primeiro precisamos aprender sobre um novo tipo chamado Booleanos. Os booleanos são nomeados em homenagem ao matemático George Boole, que definiu um sistema algébrico para determinar o valor de verdade de expressões lógicas.\nToda linguagem de programação moderna apresenta alguma representação de valores booleanos, porque muitas vezes precisamos ser capazes de declarar se algo é ou não é.\nSempre temos apenas dois valores booleanos e, em Python, esses valores são as palavras True (Verdadeiro) e False (Falso). A capitalização é importante aqui: True é um valor booleano, enquanto TRUE e true não são.\nÉ importante ressaltar que True também não é a mesma coisa que a string \u0026quot;True\u0026quot;.\nPodemos usar esses valores booleanos como quaisquer outros valores que usamos em Python até agora. Podemos atribuí-los a variáveis e colocar booleanos em tuplas e listas.\nPor exemplo, talvez queiramos armazenar informações sobre alguns filmes na lista de observação de um usuário. Podemos usar uma tupla para representar cada filme e podemos usar um booleano para representar se este filme foi ou não visto por este usuário:\nfilmes = [(\u0026#34;Tropa de Elite 2 - O Inimigo Agora é Outro\u0026#34;, 2010, True), (\u0026#34;Austin Powers 2\u0026#34;, 1999, False), (\u0026#34;O Auto da Compadecida\u0026#34;, 2000, True)] Na lista de filmes acima, o único que não assisti (False) é Austin Powers 2.\nPodemos também imprimir valores booleanos, a saída sempre será True ou Falso.\nprint(True) #True print(False) #False Valores verdadeiros Cada valor em Python tem algum valor verdade associado. Isso pode ser um pouco estranho de se pensar no início. Não é particularmente intuitivo que \u0026quot;Olá!\u0026quot; esteja de alguma forma associado a True ou False, mas isso pode ser útil, como veremos em breve.\nPodemos encontrar o valor verdadeiro de qualquer valor em Python passando esse valor para a função bool. bool retornará True ou False, dependendo do valor verdadeiro do que passamos.\nOs valores para os quais o bool retorna True são freqüentemente chamados de valores verdadeiros, enquanto os valores para os quais o bool retorna False são freqüentemente chamados de falsos.\nPor exemplo, se passarmos a string \u0026quot;Olá\u0026quot; para bool, a chamada da função será avaliada como True. \u0026quot;Olá\u0026quot; é, portanto, um valor verdadeiro.\nprint (bool (\u0026#34;Olá!\u0026#34;)) # True Vemos ver outros exemplos:\nprint(bool(0)) # False print(bool(6)) # True print(bool(\u0026#34;Morumbi\u0026#34;)) # True print(bool(\u0026#34;\u0026#34;)) # False print(bool([])) # False print(bool([0, 1, 2, 3])) # True print(bool(True)) # True print(bool(False)) # False Como podemos ver, passar True ou False para bool nos dá True e False respectivamente, mas não parece haver muita rima ou razão quando se trata dos outros valores.\nEmbora possa parecer basicamente aleatório, há de fato um padrão aqui. Apenas um pequeno número de valores em Python são falsos, que são os seguintes:\n Qualquer representação numérica de zero. Isso inclui o inteiro 0, o flutuante 0,0 e representações de zero em outros tipos numéricos. Os valores False e None. Ainda não vimos None, mas None representa a ausência intencional de um valor. Sequências vazias e outras coleções. Isso inclui strings vazias, tuplas vazias, listas vazias e vários tipos que não cobrimos neste estágio. Também é possível definirmos nossos próprios tipos e podemos torná-los falsos em certas circunstâncias, se desejarmos. Este é um tópico avançado, no entanto, e não algo que abordaremos nesta série.  Além desses valores, tudo o mais em Python é verdadeiro.\nOperadores de comparação Além da função bool, temos vários operadores de comparação que geram um valor booleano. Temos oito deles no total, cinco dos quais você provavelmente já viu antes em uma aula de matemática.\nPrimeiro, temos os operadores \u0026lt;(menor que) e \u0026gt; (maior que). No caso de \u0026lt;, o operador retorna o valor True se o primeiro operando for menor que o segundo operando; para \u0026gt;, o operador produz True se o primeiro operando for maior que o segundo operando.\nAlguns exemplos:\nprint(5 \u0026lt; 10) # True print(5 \u0026gt; 10) # False print(10 \u0026gt; 10) # False Muito semelhante a esses operadores, temos \u0026lt;= (menor ou igual a) e \u0026gt;= (maior ou igual a). Eles funcionam da mesma maneira que \u0026lt; e \u0026gt;, mas se os operandos forem de valor equivalente, obtemos True de volta em vez de False.\nprint(10 \u0026gt; 10) # False print(10 \u0026gt;= 10) # True Frequentemente, queremos verificar explicitamente se dois valores são iguais. Nesse caso, podemos usar o operador ==. == retorna True se os dois valores são iguais e False em todos os outros casos.\nTemos que ser um pouco cuidadosos aqui e lembrar que coisas como \u0026quot;0\u0026quot; não são iguais a 0. Python é inteligente o suficiente para entender que algo como 7 e 7.0 são equivalentes.\nprint(0 == \u0026#34;0\u0026#34;) # False print(0 == 0) # True print(7 == 7.0) # True print(\u0026#34;Olá\u0026#34; == \u0026#34;Olá!\u0026#34;) # False print([1, 2, 3] == [1, 2, 3]) # True Se quisermos verificar se dois valores não são iguais, temos um operador para isso também, que se parece com este !=. Este ponto de exclamação, é comumente usado para significar \u0026quot;não\u0026quot;. Portanto != significa simplesmente \u0026quot;diferente\u0026quot;.\nprint(0 != \u0026#34;0\u0026#34;) # True print(0 != 0) # False print(\u0026#34;Hello\u0026#34; != \u0026#34;Hi\u0026#34;) # True Os dois últimos que temos que olhar são um pouco mais complicados, porque eles não estão comparando os valores, por si só. Esses dois últimos operadores são is (é) is not (não são).\nSeu primeiro instinto pode ser assumir que is e == são as mesmas coisas, e o mesmo vale para is not e !=. Na verdade, eles são muito diferentes e desempenham trabalhos muito diferentes.\nPrimeiro, vejamos um exemplo:\na = [1, 2, 3] b = [1, 2, 3] print(a == b) # True print(a is b) # False Aqui temos duas listas que contêm os mesmos valores. Portanto, podemos dizer que as listas são as mesmas, e o operador == nos dá True quando comparamos os dois. No entanto, o operador is nos dá False.\nA razão pela qual obtemos essa diferença é porque, na verdade, estamos verificando se as duas listas são exatamente a mesma lista. Não que tenham os mesmos valores, mas são exatamente a mesma coisa.\nPara fazer uma analogia com o mundo real, podemos ter duas tigelas idênticas, cada uma contendo o mesmo arranjo de bolas coloridas. O operador == está verificando se as duas tigelas contêm o mesmo arranjo de bolas coloridas, enquanto is verifica se estamos falando exatamente da mesma tigela.\nQuando estamos falando sobre o que significa ser exatamente a mesma coisa em Python, o que realmente nos preocupa é se as coisas que estamos comparando estão armazenadas no mesmo local na memória.\nPodemos usar uma função chamada id para descobrir onde algo está sendo armazenado, representado como uma longa série de números. Essa longa série de números é um endereço que faz referência a um local na memória. Podemos imprimir esses endereços de memória para verificar se as duas listas não são de fato iguais:\na = [1 ,2, 3] b = [1 ,2, 3] print(id(a)) # 2886424190912 print(id(b)) # 2886424190720 print(a == b) # True print(a is b) # False Você receberá números diferentes para cada lista, e números diferentes toda vez que o programa for executado, mas o importante é que os dois números não são iguais.\nPodemos tornar as duas listas iguais fazendo uma pequena alteração. Em vez de definir essa nova lista idêntica ao atribuir a b, vamos apenas nos referir àquela que atribuímos a a:\na = [1 ,2, 3] b = a print(id(a)) # 2886424195264 print(id(b)) # 2886424195264 print(a == b) # True print(a is b) # False Agora, ambos os nossos endereços de memória são iguais e, como resultado, o operador is produz True quando comparamos a e b.\nOrdem das operações Uma nota final importante é como esses operadores de comparação interagem com os operadores aritméticos que aprendemos anteriormente.\nOs operadores de comparação sempre têm prioridade mais baixa do que os operadores aritméticos. Por exemplo, se escrevermos uma expressão como esta:\n5 + 4 \u0026lt; 3 * 2 Que nada mais é que:\n(5 + 4) \u0026lt; (3 * 2) Que resulta em:\n9 \u0026lt; 6 #False Condicionais Agora que sabemos como usar esses operadores de comparação, podemos usar os resultados dessas comparações para controlar o fluxo de nosso aplicativo. Fazemos isso usando declarações condicionais. A instrução condicional mais básica usa uma única palavra-chave: if (se).\nAs instruções condicionais nos permitem executar algum bloco no código se, e somente se, alguma condição for atendida. Podemos usar essa estrutura para controlar o fluxo de nosso aplicativo com base no fato de algo ser ou não o caso. Por exemplo, só podemos permitir que um usuário faça login em um site se ele inserir as credenciais corretas.\nVamos escrever um programa simples de barman. Vamos perguntar ao usuário a idade dele e depois verificar se ele tem menos de 18 anos. Se eles são menores de 18 anos, vamos publicar uma mensagem informando que eles são menores de idade.\nidade = int(input(\u0026#34;Qual sua idade? \u0026#34;)) if idade \u0026lt; 18: print(\u0026#34;Desculpe, não podemos te servir.\u0026#34;) Para a própria condicional, começamos com esta palavra-chave if, então temos alguma expressão seguida por dois pontos. Abaixo desta linha, temos algum bloco de código que queremos executar se a expressão que escrevemos for avaliada como um valor verdadeiro.\nEste bloco de código que queremos executar se a condição for atendida tem quatro espaços de recuo no início da linha. Este recuo é muito importante. Se você não fizer isso, o Python irá gerar uma exceção.\nFile \u0026#34;main.py\u0026#34;, line 4 print(\u0026#34;Desculpe, não podemos te servir.\u0026#34;) ^ IndentationError: expected an indented block A razão pela qual precisamos de um recuo como este é porque precisamos de alguma forma de sinalizar para o Python qual código deve ser empacotado com essa condição. Tudo o que queremos que dependa dessa condição deve ser recuado para o mesmo nível de recuo.\nVamos expandir um pouco o nosso programa de barman. Depois de verificarmos que o usuário tem de fato mais de 18 anos, quero poder solicitar ao usuário a bebida de sua escolha.\nTemos outra palavra-chave condicional disponível para nós, chamada else (senão), que nos permite fazer algo se a condição que estamos verificando não for atendida. caso contrário, não pode ser usado sozinho e precisa ser anexado a outra estrutura. Nesse caso, estamos combinando-o com uma instrução if, mas existem algumas outras opções interessantes sobre as quais falaremos em postagens futuras.\nAqui está nosso programa atualizado:\nidade = int(input(\u0026#34;Qual sua idade? \u0026#34;)) if idade \u0026lt; 18: print(\u0026#34;Desculpe, não podemos te servir.\u0026#34;) else: bebida = input(\u0026#34;O você gostaria de beber?\u0026#34;) Agora, se um usuário tiver menos de 18 anos, será informado de que não podemos atendê-lo, mas qualquer pessoa que inserir 18 ou mais no prompt inicial será questionado sobre o que gostaria de beber.\nTambém poderíamos escrever este bloco condicional assim:\nidade = int(input(\u0026#34;Qual sua idade? \u0026#34;)) if idade \u0026gt;= 18: bebida = input(\u0026#34;O você gostaria de beber?\u0026#34;) else: print(\u0026#34;Desculpe, não podemos te servir.\u0026#34;) Agora estamos verificando a condição que permitiria ao usuário prosseguir, o que é mais comum.\nÀs vezes, precisamos de mais granularidade do que isso; nesse caso, usaríamos uma cláusula elif. elif é muito parecido com if em que precisamos especificar uma expressão para testar. Bem como as outras coisas, ele não pode existir por conta própria: temos que combiná-lo com uma instrução if.\nQuando incluímos várias condições como essa, o Python passará por nossas condições uma de cada vez, até que uma seja considerada verdadeira. Depois de encontrar uma condição verdadeira, ele executa o código associado a essa condição, após o qual nenhuma outra condição é verificada para esta instrução if. Se nenhuma das condições for verdadeira, o Python executa o código recuado sob a cláusula else.\nO fato de que o Python não verifica necessariamente todas as condições é importante ter em mente por alguns motivos. Primeiro, significa que apenas o código para uma condição será executado. Em segundo lugar, significa que a ordem de nossas condições é importante, já que o Python só executará o código associado à primeira condição correspondente.\nVamos dar uma olhada em uma cláusula elif em ação mudando um pouco nosso exemplo. Mais uma vez, vamos perguntar a idade do usuário, e dizer se ele é elegível a não pagar a tarifa de onibus\nPodemos escrever algo assim:\nidade = int(input(\u0026#34;Qual sua idade? \u0026#34;)) if idade \u0026lt; 6: print(\u0026#34;Você é uma criança de até 6 anos, não paga a passagem.\u0026#34;) elif idade \u0026gt; 65: print(\u0026#34;Você é um idoso maior de 65 anos, não paga a passagem.\u0026#34;) else: print(\u0026#34;Você paga a passagem!\u0026#34;) Valores verdadeiros e condicionais Não estamos limitados a apenas usar operadores de comparação com instruções condicionais. Por exemplo, podemos usar o valor verdade de qualquer valor como uma condição. É aqui que os valores verdadeiros se tornam realmente úteis, pois nos permitem fazer coisas como verificar sucintamente se uma coleção está vazia.\nPor exemplo, podemos verificar se o usuário realmente inseriu algo quando solicitamos alguma entrada:\nnome = input(\u0026#34;Qual o seu nome? \u0026#34;) if nome:\t# verifica se o usuário digitou algo (booleano) print(f\u0026#34;Você digitou {nome}.\u0026#34;) else: print(\u0026#34;Você não digitou nada!\u0026#34;) Analisaremos esse padrão nas próximas aulas, então não se preocupe se isso estiver um pouco confuso agora.\nExercícios   Crie duas variáveis, a atribua em cada uma delas seu primeiro nome de forma idêntica. Verifique se elas são iguais (==) e se são a mesma variável (is)\n  Solicite ao usuário um número. Retorne ao usuário informando se o número é positivo, negativo ou zero.\n  Escreva um programa para determinar se um funcionário deve fazer horas extras. Você deve perguntar ao usuário quantas horas o funcionário trabalhou nesta semana, bem como o salário por hora para este funcionário.\nSe o funcionário trabalhou mais de 40 horas, você deve imprimir uma mensagem informando que o funcionário deve receber um pagamento adicional, bem como o valor devido. O valor adicional devido é de 10% do salário-hora do empregado para cada hora trabalhada nas 40 horas. Com efeito, os funcionários recebem 110% do seu salário por hora para qualquer hora extra.\n  "
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula04/",
	"title": "4. Coleções - Listas e Tuplas",
	"tags": [],
	"description": "",
	"content": " Listas  Acessando valores em uma lista Adicionando itens a lista Removendo itens de uma lista   Tuplas  Acessando valores em uma tupla Tuplas vs Listas   Acessando valores em coleções aninhadas Exercícios  Listas A primeira nova coleção que veremos são as listas.\nSimplificando, as listas são contêineres para outros valores. Ao contrário das strings, que são coleções apenas de caracteres, as listas podem armazenar quaisquer valores que desejemos. Podemos até misturar diferentes tipos de valores, se quisermos.\nDefinimos uma lista usando colchetes como este:\nnomes = [\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] Cada valor é colocado entre colchetes, separados por vírgulas.\nNesse caso, definimos uma lista em uma linha. Aqui está tudo bem, mas às vezes pode ficar um pouco difícil de ler. Por exemplo, e se estivermos tentando armazenar uma lista de títulos de filmes e tivermos strings como \u0026quot;Tropa de Elie 2 - O Inimigo Agora é Outro\u0026quot;? Muito rapidamente, acabaremos com um código excedendo a largura de nossas telas. O mesmo se aplica se tivermos muitos e muitos valores.\nQuando nos deparamos com uma situação como esta, podemos dividir a lista em várias linhas da seguinte forma:\nfilmes = [\u0026#34;Tropa de Elite 2 - O Inimigo Agora é Outro\u0026#34;, \u0026#34;Austin Powers 2\u0026#34;, \u0026#34;O Auto da Compadecida\u0026#34;] Como mencionei anteriormente, podemos misturar qualquer tipo de valor que quisermos em uma lista, você não precisa ter apenas strings ou apenas inteiros.\nrei = [\u0026#34;Edson Arantes do Nascimento\u0026#34;, 80, \u0026#34;Jogador de Futebol\u0026#34;] Também é possível definir uma lista sem conteúdo, que é representada por um par vazio de colchetes [].\nPodemos imprimir na tela uma lista inteira apenas passando-a a função print, como abaixo:\nrei = [\u0026#34;Edson Arantes do Nascimento\u0026#34;, 80, \u0026#34;Jogador de Futebol\u0026#34;] print(rei) No entanto, geralmente estamos interessados nos valores dentro de uma lista, e não na lista como um todo, então vamos ver como acessar os valores da lista.\nAcessando valores em uma lista Cada valor em uma lista é indexado de acordo com sua posição na lista. O item na primeira posição está no índice 0; o item na segunda posição está no índice 1; e assim por diante.\nPodemos acessar valores em uma lista usando esses índices, e geralmente fazemos isso com uma parte da sintaxe chamada expressão de assinatura.\nExpressões de assinatura são usadas para acessar valores em muitas coleções. Para sequências, eles são usados para acessar elementos por índice.\nÉ mais ou menos assim:\nnomes = [\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] print(nomes[1]) #Alice Para recuperar o valor Alice dos nomes, escrevemos o nome da lista que desejamos acessar e, em seguida, dentro de alguns colchetes, colocamos o índice do item que desejamos recuperar.\nTambém é possível se referir a um índice negativo, o que nos permite trabalhar a partir do final da lista. Nesse caso, o item no índice -1 é o último item; o item como índice -2 é o penúltimo item; e assim por diante.\nnomes = [\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] print(nomes[-1]) #Tiago Isso pode ser muito útil quando queremos o item final de uma lista, pois nos poupa ter que fazer cálculos para descobrir o índice do item final.\nAdicionando itens a lista Uma característica interessante das listas é que elas são mutáveis: podemos alterar os valores internos. Isso significa que podemos adicionar valores, removê-los, substituí-los, reordená-los, etc.\nPrimeiro, vamos nos concentrar em adicionar itens a uma lista usando o método append. Como o nome pode sugerir, append nos permite adicionar um item ao final de uma lista. Mais uma vez, precisamos usar a notação de ponto para chamar append e colocamos o valor que queremos adicionar entre parênteses quando o chamamos.\nnomes = [\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] nomes.append(\u0026#34;Evelin\u0026#34;) print(nomes[-1]) #Evelin Também podemos adicionar outro item (ou itens) a uma lista usando o operador +. Nesse caso, ambos os operandos devem ser listas.\nA abordagem também é um pouco diferente, pois temos que realizar uma atribuição como parte da operação.\nnomes = [\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] nomes = nomes + [\u0026#39;Evelin\u0026#39;] print(nomes[-1]) #Evelin Isso às vezes pode ser útil, porque não modifica a lista original, já que a operação produz uma nova lista. append, por outro lado, modifica a lista existente.\nAlém do método append e do operador +, também temos um método chamado extend, que nos permite adicionar vários itens ao final de uma lista existente.\nTodos são ótimos para adicionar um item ao final de uma lista, mas e se quisermos adicionar um item no meio? Para isso, temos o método insert.\ninsert é um pouco mais complicado do que as opções que vimos até agora, pois precisa de duas informações. Primeiro, precisamos dizer onde queremos inserir o valor e, segundo, precisamos dizer o que queremos inserir.\nPor exemplo, digamos que temos uma lista como esta:\nnumeros = [1, 2, 4, 5] No momento, estamos perdendo o valor 3 nesta sequência e queremos inserir esse valor no índice 2. Portanto, precisamos chamar o insert desta forma:\nnumeros = [1, 2, 4, 5] numeros.insert(2, 3) print(numeros) #[1,2,3,4,5] Como você pode ver, os outros valores foram misturados corretamente para abrir espaço para nossa nova adição.\nUma coisa que você pode estar se perguntando é: o que acontece se especificarmos um índice fora da lista definida? Em vez disso, Python apenas coloca o item como o final:\nnumeros = [1, 2, 4, 5] numeros.insert(7, 3) print(numeros) #[1,2,3,4,5] Removendo itens de uma lista Assim como na adição de itens, existem várias opções disponíveis para uso quando se trata de remover itens de uma lista.\nPrimeiro, temos o método remove. remove mais uma vez usa a sintaxe de ponto que vimos várias vezes agora e remove o primeiro item que corresponde ao valor que passamos.\nPor exemplo, se tivermos uma lista como esta:\nnomes = [\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] Podemos remover o primeiro nome João chamando remove:\nnomes = [\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] nomes.remove(\u0026#34;João\u0026#34;) print(names) #[\u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] A segunda instância de \u0026quot;João\u0026quot; é deixada intacta e tudo muda para a esquerda para que não tenhamos um buraco em nossa lista.\nÀs vezes, não sabemos necessariamente o valor que queremos remover, mas sabemos onde o valor está em nossa lista. Em casos como esse, temos algumas opções.\nPrimeiro, podemos usar a palavra-chave del. del pode ser usado para excluir qualquer coisa que quisermos, incluindo uma lista inteira, mas se usarmos uma expressão de assinatura, podemos usá-la para remover um item em um índice específico.\nnomes = [\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] del nomes[2] print(names) #[\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Tiago\u0026#34;] A principal alternativa que temos para usar del é pop. Por padrão, o pop removerá o último item da lista, mas podemos opcionalmente passar um índice como um argumento para remover um item diferente.\nnomes = [\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] nomes.pop() print(nomes) #[\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;] nomes.pop(1) print(nomes) #[\u0026#34;João\u0026#34;, \u0026#34;Sarah\u0026#34;] Uma das coisas realmente úteis sobre pop é que a expressão de chamada do método avalia o item que removemos da lista. Podemos, portanto, usar isso para remover um item que planejamos usar para alguma operação futura:\nnomes = [\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] ultimo_da_lista = nomes.pop() print(nomes) #[\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;] print(ultimo_da_lista) #Tiago Finalmente, temos o clear. Este é muito simples, ele apenas removerá tudo dentro de uma determinada lista:\nnomes = [\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] nomes.clear() print(nomes) #[] Tuplas As tuplas são como listas, porém são valores nas quais não iremos alterar, são imutáveis. Exemplo, a largura e altura da janela de um jogo. Assim definimos estes padrões e elas não serão alteradas.\nTudo o que precisamos para definir uma tupla é uma série de valores separados por vírgulas:\nnomes = \u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34; Mais frequentemente, no entanto, veremos tuplas escritas assim:\nnomes = (\u0026#34;João\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;) Na maioria das vezes, esses parênteses são opcionais - são as vírgulas que são importantes - mas há casos em que realmente precisamos deles para distinguir o conteúdo da tupla de outros valores separados por vírgula.\nPor exemplo, é totalmente legal (e comum) colocar tuplas em uma lista. Talvez queiramos armazenar nomes de filmes e datas de lançamento juntos em uma lista de filmes como esta:\nfilmes = [(\u0026#34;Tropa de Elite 2 - O Inimigo Agora é Outro\u0026#34;, 2010), (\u0026#34;Austin Powers 2\u0026#34;, 1999), (\u0026#34;O Auto da Compadecida\u0026#34;, 2000)] Acessando valores em uma tupla Muito parecido com as listas, as tuplas são coleções ordenadas, onde cada item pode ser acessado por índice com base em sua posição na coleção.\nAté usamos a mesma sintaxe de expressão de assinatura para acessar itens em uma tupla.\nTuplas vs Listas Uma das grandes diferenças entre tuplas e listas é que as tuplas são imutáveis. Não podemos mudá-los, uma vez que os definimos.\nIsso significa que você não encontrará nenhum método pop ou append para tuplas, e a função del não permitirá que você remova valores usando um índice.\nUma coisa que funcionará é o operador +, mas se nos lembrarmos de nossa discussão de + com listas, esse operador nos dá uma nova coleção. Se o usarmos com uma tupla, a tupla original permanecerá inalterada: acabamos de criar uma nova.\nObserve que você só pode usar + para juntar duas tuplas.\nO fato de que as tuplas não podem mudar é uma propriedade muito desejável, porque nos permite definir uma estrutura consistente para seus conteúdos, o que significa que usamos os valores como células em uma linha de tabela. Deixe-me mostrar o que quero dizer.\nDigamos que temos três informações que queremos armazenar para cada filme de nossas coleções. Queremos o título do filme, o nome do diretor e o ano de lançamento.\nPosso definir minha coleção de filmes assim:\nfilmes = [ ( \u0026#34;Tropa de Elite 2 - O Inimigo Agora é Outro\u0026#34;, \u0026#34;José Padilha\u0026#34;, 2010 ), ( \u0026#34;Austin Powers 2\u0026#34;, \u0026#34;Jay Roach\u0026#34;, 1999 ), ( \u0026#34;O Auto da Compadecida\u0026#34;, \u0026#34;Guel Arraes\u0026#34;, 2000 )] Acessando valores em coleções aninhadas Agora temos algumas instâncias de coleções aninhadas - tuplas dentro de uma lista, por exemplo - então precisamos falar brevemente sobre como obter itens dessas coleções internas.\nLembre-se de que quando escrevemos algo como minha_lista [0], esta é uma expressão de inscrição. O valor que ele nos fornece é o valor no índice solicitado na coleção que especificamos.\nPortanto, se tivermos uma coleção como esta:\nfilmes = [(\u0026#34;Tropa de Elite 2 - O Inimigo Agora é Outro\u0026#34;, 2010), (\u0026#34;Austin Powers 2\u0026#34;, 1999), (\u0026#34;O Auto da Compadecida\u0026#34;, 2000)] E solicitamos um valor:\nfilmes[0] Obtemos a primeira tupla da lista:\n(\u0026#34;Tropa de Elite 2 - O Inimigo Agora é Outro\u0026#34;, 2010) Portanto, se quisermos o título deste filme, que sabemos estar no índice 0, podemos adicionar outro conjunto de colchetes como:\nfilmes[0][0] # \u0026#34;Tropa de Elite 2 - O Inimigo Agora é Outro\u0026#34; Exercícios  Crie uma lista de filmes contendo uma única tupla. A tupla deve conter o título do filme, o nome do diretor, o ano de lançamento do filme e o orçamento do filme. Use a função input para coletar informações sobre outro filme. Você precisa de um título, nome do diretor, ano de lançamento e orçamento. Crie uma nova tupla a partir dos valores que você reuniu usando a entrada. Certifique-se de que eles estão na mesma ordem que a tupla que você escreveu na lista de filmes. Use uma string f para imprimir o nome do filme e o ano de lançamento, acessando sua nova tupla de filme. Adicione a nova tupla de filme à coleção de filmes usando append. Imprima ambos os filmes da coleção de filmes. Remova o primeiro filme dos filmes. Use o método que desejar.  "
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula03/",
	"title": "3. Formatando Strings e Processando Entrada do Usuário",
	"tags": [],
	"description": "",
	"content": " Concatenação de string Convertendo strings, inteiros e floats Interpolação de strings com o método format Comentários Processamento básico de strings  Processando múltiplas linhas   Exercícios  Nesta vamos falar sobre concatenar strings (juntar strings), interpolação de strings (colocar valores dentro de strings) e processar a entrada do usuário. Também vamos falar sobre como podemos documentar melhor nosso código usando comentários.\nConcatenação de string Vamos começar com o reasultado do exercício da aula anterior:\nvalor_hora = input(\u0026#34;Digite o valor da sua hora de trabalho: \u0026#34;) horas_trabalhadas = input(\u0026#34;Quantas horas você trabalhou esta semana? \u0026#34;) print(\u0026#34;Valor hora: \u0026#34;) print(valor_hora) print(\u0026#34;Horas trabalhadas: \u0026#34;) print(horas_trabalhadas) Aqui, pedimos ao usuário duas informações e, em seguida, imprimimos essas informações de volta no console junto com alguns cabeçalhos.\nIsso é muito bom, mas não seria bom se pudéssemos ter o valor valor_hora na mesma linha que o rótulo \u0026quot;Valor hora: \u0026quot;? É aqui que entra a concatenação de strings (juntando duas ou mais strings).\nConcatenar coisas significa juntar ou ligar coisas, e é isso que queremos fazer com nossas strings. Queremos pegar a string, \u0026quot;Valor hora: \u0026quot;, e queremos juntar a ela a string que atribuímos à variável,valor_hora.\nEm Python, podemos apenas usar o operador + para isso, assim:\nvalor_hora = input(\u0026#34;Digite o valor da sua hora de trabalho: \u0026#34;) horas_trabalhadas = input(\u0026#34;Quantas horas você trabalhou esta semana? \u0026#34;) print(\u0026#34;Valor hora: \u0026#34; + valor_hora) print(\u0026#34;Horas trabalhadas: \u0026#34; + horas_trabalhadas) Muito parecido com quando usamos + para somar números, podemos encadear quantas strings quisermos usando +. No entanto, devemos ter muito cuidado para não combinar os tipos.\nPor exemplo, não podemos fazer algo assim, em que tentamos juntar um inteiro em uma string:\nprint(\u0026#34;Valor hora: \u0026#34; + valor_hora) Se executarmos este programa, o Python retornará o seguinte erro:\nDesta vez, obtemos um TypeError, que nos diz que tentamos concatenar um int (inteiro) em uma str (string), mas esta operação só é suportada entre strings.\nPortanto, a questão agora é: o que faremos se precisarmos realizar algumas operações aritméticas e, em seguida, colocar o resultado em uma string? Felizmente, o Python nos fornece algumas ferramentas para converter valores de um tipo em outro.\nConvertendo strings, inteiros e floats Primeiro, vamos falar sobre a conversão de inteiros e flutuantes em strings. A ferramenta que usaremos é a chamada str, e podemos pensar nela como sendo muito parecida com uma função.\nQuando chamamos str, passando um inteiro ou um float, vamos obter uma nova string contendo os numerais que compõem o número, junto com as casas decimais no caso de floats.\nPor exemplo, podemos escrever algo assim:\nidade = str(12) O que vai atribuir à idade a mesma coisa que se escrevêssemos:\nidade = \u0026#34;12\u0026#34; Converter de uma string em um inteiro ou float é um pouco mais complicado, porque nem toda string é um número válido. Além disso, mesmo se uma string for um número válido, pode não ser um número válido do tipo para o qual estamos tentando converter.\nSe quisermos converter uma string em um inteiro, precisamos chamar int, passando a string. Os caracteres da string devem representar um número inteiro.\nidade = int(\u0026#34;12\u0026#34;) ⚠️ Se tentarmos passar uma representação de string de um número com casas decimais, vamos obter um TypeError. Por exemplo, algo assim:\nvalor_hora = int(\u0026#34;20.53\u0026#34;) ⚠️ Ao executar retornará a seguinte mensagem de erro:\nTraceback (most recent call last): File \u0026#34;main.py\u0026#34;, line 1, in \u0026lt;module\u0026gt; int(\u0026#34;20.53\u0026#34;) ValueError: invalid literal for int() with base 10: \u0026#39;20.53\u0026#39; Ao invés de int, necessitamos chamar float:\nvalor_hora = float(\u0026quot;20.53\u0026quot;) ✔️ float também pode manipular a entrada sem um componente decimal. Por exemplo, se passarmos \u0026quot;20\u0026quot;, vamos obtê-lo com casas decimais 20.0 de volta.\nAlém de converter de strings em inteiros e flutuantes, e vice-versa, também podemos converter entre inteiros e flutuantes usando o mesmo int e float. Neste caso, passar um float para int vai funcionar, mas vai \u0026ldquo;truncar\u0026rdquo; o float, essencialmente jogando fora tudo após a vírgula decimal.\nTruncamento é o ato de encurtar algo removendo alguma parte dele. Por exemplo, podemos nos referir a truncar um float, o que significa que estamos removendo tudo após o ponto decimal.\nInterpolação de strings com o método format A concatenação de strings é uma coisa útil de se saber, mas é um pouco desajeitada e está sujeita a erros de espaçamento, como vimos. Uma abordagem melhor costuma ser usar a interpolação de strings, especialmente ao trabalhar com conteúdo que tem uma estrutura semelhante a uma frase.\nA interpolação de string é o ato de inserir algum conteúdo novo em uma string existente.\nAo contrário da concatenação, a interpolação depende de colocarmos marcadores em uma string que podemos preencher com valores. Isso torna muito mais difícil cair em problemas de formatação, porque os marcadores de posição estão na posição exata que os valores irão ocupar. Outro grande benefício da interpolação: não precisamos nos preocupar com os tipos! Python irá garantir que obteremos uma representação de string de todos os nossos valores.\nExistem várias maneiras de realizar a interpolação de string em Python, mas primeiro veremos como usar o método de formatação format.\nO método format possuí diversas formas de ser utilizado, utilizaremos a forma simplificada dele. 😉\nAo usar o método format, os marcadores de posição para nossos valores são chaves, que se parecem com isto: {}. Por exemplo, digamos que queremos escrever uma string como:\n\u0026#34;Tiago tem 35 anos!\u0026#34; Mas em vez de apenas \u0026quot;Tiago\u0026quot; e \u0026quot;35\u0026quot;, queremos ser capazes de escrever qualquer nome e qualquer idade aqui. Tudo o que temos que fazer é substituir \u0026quot;Tiago\u0026quot; e \u0026quot;35\u0026quot; por chaves, assim:\nf\u0026#34;{}tem {}anos!\u0026#34; Usando este exemplo, nosso programa ficaria assim:\nnome = \u0026#34;Tiago\u0026#34; idade = 35 print(f\u0026#34;{nome}tem {idade}anos!\u0026#34;) Podemos também utilizar o método para escrever expressões dentro dentro dele:\nnome = \u0026#34;Tiago\u0026#34; idade = 35 print(f\u0026#34;{nome}tem {idade*12}meses de idade!\u0026#34;) Comentários Usando nomes bons e descritivos, podemos fazer muito para tornar nosso código autodocumentado; no entanto, às vezes, mesmo um bom código pode ser difícil de entender. Afinal, algumas coisas são complicadas.\nEm casos como este, pode ser útil usar comentários para explicar aos leitores de nosso código (o que nos inclui) o que o código está fazendo.\nPara escrever um comentário, só precisamos colocar um # diretamente antes da mensagem que queremos escrever. Isso dirá ao Python para não tratar o que se segue como código.\nnome = \u0026#34;Tiago\u0026#34; idade = 35 #Imprime a idade em meses print(f\u0026#34;{nome}tem {idade*12}meses de idade!\u0026#34;) Tente não exagerar nos comentários, pois comentários em todas as linhas podem causar mais danos do que benefícios no que diz respeito à legibilidade.\nProcessamento básico de strings A última coisa que é bom mencionar nesta aula são algumas operações comuns de processamento de strings, como alterar a caixa das letras ou remover espaços em branco (caracteres de espaço, tabulações, novas linhas, etc.) das extremidades das strings. Esse tipo de coisa acontece o tempo todo quando lidamos com a entrada do usuário.\nTemos várias opções diferentes para alterar a caixa das letras em uma string. Aqui, vamos nos concentrar em quatro opções importantes: lower, upper, capitalize e title.\nlower e upper transformam a string inteira em minúsculas e maiúsculas, respectivamente. Os caracteres que não possuem maiúsculas e minúsculas, como caracteres de pontuação, são ignorados.\ncapitalize vai transformar o primeiro caractere em maiúsculas, com o resto em minúsculas. title vai transformar a string em maiúsculas, o que significa que cada palavra começa com uma letra maiúscula e todas as outras letras são transformadas em minúsculas.\nPara utilzar estes métodos, escrevemos da seguinte forma:\n\u0026#34;Olá, Mundo!\u0026#34;.lower() # \u0026#34;ola, mundo!\u0026#34; \u0026#34;Olá, Mundo!\u0026#34;.upper() # \u0026#34;OLÁ, MUNDO!\u0026#34; \u0026#34;Olá, Mundo!\u0026#34;.capitalize() # \u0026#34;Olá, mundo!\u0026#34; \u0026#34;Olá, Mundo!\u0026#34;.title() # \u0026#34;Olá, Mundo!\u0026#34; Em cada caso, estamos escrevendo uma expressão, e o valor dessa expressão é uma nova string no caso solicitado.\nNão há muito mais a fazer quando se trata de mudar de caixa, mas que tal remover o espaço em branco no fim das strings? Para isso, podemos usar o método strip.\nstrip é na verdade muito mais versátil do que isso, e podemos fazer com que ele remova qualquer coisa que quisermos, mas por padrão ele nos dará uma string nova com qualquer espaço em branco estranho removido de ambas as extremidades.\nNós o usamos exatamente da mesma maneira que lower, upper, etc.\n\u0026#34; Olá, Mundo! \u0026#34;.strip() # \u0026#34;Olá, Mundo!\u0026#34; Perceba no exemplo acima como os espaços das extremidade são removidas.\nProcessando múltiplas linhas Podemos aplicar vários métodos de processamento a uma string. Deixe-me mostrar duas maneiras de fazer isso.\nA primeira forma envolve a criação de uma variável e a reatribuição a ela para cada chamada de método, assim:\nuser_name = \u0026#34; ANA OLIVEIRA \u0026#34; user_name = user_name.strip() # \u0026#34;ANA OLIVEIRA\u0026#34; user_name = user_name.title() # \u0026#34;Ana Oliveira\u0026#34; Embora isso seja muito repetitivo, e reatribuir a uma variável várias vezes geralmente pareça ineficiente (embora não seja lento, Python pode reatribuir a variáveis muito rapidamente).\nPortanto, a segunda maneira de fazer isso envolve usar o resultado de cada etapa em linha, assim:\nuser_name = \u0026#34; ANA OLIVEIRA \u0026#34;.strip().title() Aprenderemos mais sobre como isso funciona exatamente quando examinarmos as funções e os valores de retorno, mas por enquanto tratamos cada chamada de método, como \u0026quot;ANA OLIVEIRA\u0026quot;.strip(), como a string que ela devolveria a você.\nExercícios  Utilizando a variável abaixo, imprima \u0026quot;Olá , mundo!\u0026quot;:  saudacao = \u0026#34;Olá, mundo\u0026#34; Você pode adicionar o ponto de exclamação ausente usando concatenação de string ou format. A escolha é sua.\n Peça o nome do usuário e, em seguida, cumprimente-o, usando o nome dele como parte da saudação. O nome deve estar em caixa do título (title) e não deve ser circundado por nenhum espaço em branco.\nPor exemplo, se o usuário digitar \u0026ldquo;eduardo\u0026rdquo;, sua saída deve ser algo assim:\nOlá, Eduardo!   Concatene a string \u0026quot;Eu tenho\u0026quot; , inteiro 48, e novamente outra string \u0026quot;anos.\u0026quot; para pruduzir uma string \u0026quot;Eu tenho 48 anos.\u0026quot; Lembre-se de que só podemos concatenar strings para outras strings, portanto, você terá que converter o inteiro em uma string antes de realizar a concatenação.\n  Formate e imprima as informações abaixo utilizando interpolação de strings:]\ntitulo = \u0026#34;O Coringa\u0026#34; diretor = \u0026#34;Todd Phillips\u0026#34; ano = 2019 O resultado deve parecer como o abaixo:\nO Coringa (2019), dirigido por Todd Phillips.   "
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]