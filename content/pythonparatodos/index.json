[
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula01/",
	"title": "1. N√∫meros, Aritm√©tica e Impress√£o na Tela!",
	"tags": [],
	"description": "",
	"content": " Um pouco sobre Python Um pouco sobre Python N√∫meros b√°sicos A fun√ß√£o print  ‚ö†Ô∏è Dica de formata√ß√£o   Uma r√°pida olhada nas express√µes  Operadores aritm√©ticos Utilizando m√∫ltiplos operadores Agrupando opera√ß√µes com par√™nteses  ‚ö†Ô∏è Dica de formata√ß√£o     Exerc√≠cios  Bem-vindo a nossa primeira aula de Python! Vamos falar sobre os diferentes tipos de n√∫mero em Python, impress√£o de valores e execu√ß√£o de aritm√©tica simples. Tamb√©m vamos discutir brevemente o conceito de express√µes.\nUm pouco sobre Python A primeira vers√£o do Python foi lan√ßada h√° 30 anos em 1990. Desde ent√£o, a linguagem passou por uma grande quantidade de mudan√ßas e se tornou uma das linguagens de programa√ß√£o mais populares do mundo.\nUm dos principais pontos fortes do Python √© a legibilidade de seu c√≥digo, o que o torna extremamente acess√≠vel. Frequentemente, o c√≥digo Python √© lido exatamente como o ingl√™s. Python tamb√©m √© extremamente flex√≠vel e pode ser encontrado em uma ampla variedade de setores, desde aprendizado de m√°quina at√© desenvolvimento web.\nNo momento em que este artigo foi escrito, havia dois principais padr√µes Python em uso ativo.\nPrimeiro, temos o Python 2.7, que √© a vers√£o mais atual do Python 2. O Python 2 tecnicamente atingiu o fim de sua vida √∫til e n√£o receber√° mais atualiza√ß√µes adicionais, mas ainda h√° uma grande quantidade de c√≥digo do Python 2 por a√≠!\nA nova vers√£o do Python √© o Python 3, com a vers√£o mais atual sendo o Python 3.9. O Python 3 foi criado para ser um substituto do Python 2 e apresenta uma s√©rie de melhorias junto com algumas mudan√ßas significativas de sintaxe. O c√≥digo escrito em Python 2 pode n√£o ser compat√≠vel com Python 3 e, mesmo que o c√≥digo seja executado, podemos ter um comportamento inesperado.\nAo longo desta s√©rie, trabalharemos com Python 3.\nN√∫meros b√°sicos Em Python, temos v√°rias maneiras diferentes de representar n√∫meros, as mais comuns s√£o inteiros e n√∫meros de ponto flutuante - tamb√©m conhecidos como \u0026ldquo;n√∫meros quebrados\u0026rdquo;\u0026hellip;rsrs\nInteiros e flutuantes s√£o tipos num√©ricos b√°sicos em Python. Os inteiros s√£o usados para representar n√∫meros inteiros e os floats s√£o usados para n√∫meros reais com algum componente decimal. Por exemplo, usar√≠amos um inteiro para o n√∫mero 3, mas um float para 3.141.\nCriar um n√∫mero inteiro em Python √© muito simples: s√≥ precisamos escrever um n√∫mero inteiro (tamb√©m conhecido como n√∫mero inteiro). Por exemplo, podemos criar um n√∫mero inteiro com o valor 4 assim:\n4 Podemos tamb√©m escrever n√∫meros negativos inteiros, colocando um - antes do n√∫mero:\n6 Floats s√£o criados da mesma forma, por√©m eles possuem casas decimais. Em outras palavras, h√° algo depois do ponto, mesmo que isto seja um 0.\nTodos os n√∫meros abaixo s√£o considerados floats:\n4.0 -156.9 2.842 Por√©m, n√£o sei se voc√™ tentou executar algum destes c√≥digos, nada acontece. Precisamos fazer algo para que eles sejam exibidos.\nA fun√ß√£o print O Python possui uma fun√ß√£o nativa que exibe informa√ß√µes para n√≥s na tela. Esta fun√ß√£o seja chama print.\nVamos cobrir as fun√ß√µes com muitos detalhes ao longo desta s√©rie, mas por enquanto voc√™ pode pensar nas fun√ß√µes como pacotes de c√≥digo que podemos executar para realizar alguma a√ß√£o espec√≠fica.\nAlgu√©m gentilmente escreveu o c√≥digo (bastante complicado) que nos permite imprimir coisas no console, e eles o agruparam em uma fun√ß√£o chamada print. Podemos executar esta fun√ß√£o para realizar a a√ß√£o de impress√£o.\nO processo de execu√ß√£o de uma fun√ß√£o como essa costuma ser referenciado de ‚Äúchamada‚Äù de uma fun√ß√£o.\nEm vez de \u0026ldquo;chamar\u0026rdquo;, alguns dizem \u0026ldquo;rodando\u0026rdquo; ou \u0026ldquo;executando\u0026rdquo; uma fun√ß√£o. Todos eles significam a mesma coisa!\nVamos chamar a fun√ß√£o de impress√£o (print) para imprimir o valor 4 no console:\nprint(4) Podemos utilizar esta fun√ß√£o m√∫ltiplas vezes se n√≥s quisermos, e os valores ser√£o impressos na tela conforme a fun√ß√£o print √© chamada:\nprint(4.0) print(-156.9) print(2.842) Primeiro n√≥s imprimimos 4, depois em uma linha separada temos -156.9, e finalmente 2.842 na √∫ltima linha. Como voc√™ pode ver , n√£o precisamos de nada especial para imprimir qualquer uma das linhas.\n‚ö†Ô∏è Dica de formata√ß√£o Sempre que chamarmos uma fun√ß√£o, recomenda-se que os par√™nteses devem sem escritos logo ap√≥s o nome da fun√ß√£o. Por exemplo:\nprint(4) E n√£o desta forma.\nprint (4) Isso n√£o vai afetar a forma como o c√≥digo funciona - Python n√£o se importa se colocarmos espa√ßos aqui - √© apenas considerado um estilo ruim, e desenvolver um bom estilo de codifica√ß√£o √© muito importante. Um bom estilo ajudar√° a tornar seu c√≥digo mais leg√≠vel, o que √© uma das m√©tricas mais importantes a se considerar quando se trata de escrever c√≥digo.\nUma r√°pida olhada nas express√µes Antes de passarmos para a pr√≥xima se√ß√£o, precisamos apresentar uma nova palavra: express√£o.\nSe algo em nosso c√≥digo for avaliado como um valor, √© uma express√£o. Tenha paci√™ncia, isso vai fazer muito mais sentido em um momento.\nPor acaso, cada peda√ßo de c√≥digo que escrevemos at√© agora √© uma express√£o e existem muitos tipos diferentes de express√£o em Python.\nPor exemplo, todos os inteiros que escrevemos s√£o express√µes. Quando o Python v√™ cada n√∫mero inteiro, ele pode usar o valor que eles representam.\nTamb√©m estamos prestes a ver algumas opera√ß√µes aritm√©ticas simples, como 5 + 7, e essas opera√ß√µes tamb√©m s√£o express√µes. No caso de 5 + 7, quando Python v√™ isso, ele avalia a express√£o para outro n√∫mero inteiro: 12.\nQuando escrevemos print(), esse tamb√©m √© um tipo de express√£o chamada express√£o de chamada de fun√ß√£o.\nIsso significa que print() tem um valor?\nSim, √© verdade, e falaremos muito mais sobre isso quando chegarmos √†s fun√ß√µes mais adiante.\nVejamos os operadores aritm√©ticos e come√ßaremos a ver por que esse conceito de express√£o √© importante.\nOperadores aritm√©ticos Uma das coisas que fazemos o tempo todo em Python (e programa√ß√£o em geral) √© aritm√©tica b√°sica. Conseguimos isso principalmente por meio do uso de s√≠mbolos de operador como +, -, /, etc.\nPor exemplo, se quisermos somar dois n√∫meros, podemos colocar o operador + entre esses dois n√∫meros:\n1 + 2 3.4 + 11 8 + 4.0 Quando usamos um operador como este, estamos escrevendo uma express√£o. Ent√£o, quando escrevemos 1 + 2, Python avalia isso e obtemos um inteiro com o valor 3.\n√â importante ter isso em mente, porque afeta nossa sa√≠da quando usamos algo como print. Se tentarmos imprimir algo assim:\nprint(1+2) O Python n√£o ir√° imprimir a opera√ß√£o, porque no momento em que print √© executado, a opera√ß√£o 1+2 j√° havia sido calculada, e obtido o valor inteiro 3.\nVamos ver alguns exemplos:\nprint(1 + 2) print(3.4 + 11) print(8 + 4.0) Se voc√™ executou o c√≥digo acima, deve ter notado algo interessante. Em vez de obter 3, 14.4 e 12 impressos na tela, o resultado final foi 12.0.\nIsso ocorre porque se qualquer um dos operandos para + for um float, a express√£o ser√° avaliada como um float. O mesmo √© verdade para v√°rios dos outros operadores, incluindo - e * (que √© usado para multiplica√ß√£o).\nEsses dois operadores funcionam exatamente da mesma maneira que +, ent√£o n√£o precisamos falar sobre eles em muitos detalhes, mas aqui est√£o alguns exemplos:\nprint(7 - 5) print(5 - 11.0) print(-4 - 9) print(4 * 7) print(2 * 29.0) print(8.2 * 34) A divis√£o √© executada usando o operador /, mas ao executar a divis√£o, o resultado √© sempre um float. N√£o importa se ambos os n√∫meros s√£o inteiros ou se o resultado normalmente seria um n√∫mero inteiro. Voc√™ pode ver isso executando o c√≥digo abaixo:\nprint(5 / 6.5) print(20 / 2) print(5.5 / 0.5) Utilizando m√∫ltiplos operadores √Äs vezes, precisamos realizar c√°lculos mais complicados, e isso pode envolver o uso de v√°rios operadores. Isso √© totalmente normal em Python, e podemos encadear quantos desses operadores aritm√©ticos quisermos. Apenas certifique-se de que as coisas n√£o estejam ficando dif√≠ceis de ler. Isso n√£o √© bom:\n5 + 4 + 8 + 565 + 454.0 + 9 + 2 + 11 + 3 + 20 + 45 + 67 Podemos tamb√©m encadear na opera√ß√£o diferentes opera√ß√µes.\n5 * 3 - 6 + 2 / 4 Agrupando opera√ß√µes com par√™nteses Assim como j√° pudemos ver em nossas aulas de matem√°tica na escola, utilizamos par√™nteses para agrupar as opera√ß√µes, determinando assim a ordem de opera√ß√£o. Tudo o que estiver dentro de par√™nteses ser√° calculado primeiro.\n(4 - 5) * (5 + 3) / 2 Na linha acima, (4 - 5) √© calculado primeiro e, em seguida, (5 + 3). A multiplica√ß√£o √© ent√£o realizada e, finalmente, a divis√£o. O resultado √© um n√∫mero inteiro com o valor -4.\nPodemos colocar tudo isso entre par√™nteses ao chamar print se quisermos ver a sa√≠da:\n‚ö†Ô∏è Dica de formata√ß√£o Quando escrevemos operadores bin√°rios (operadores com dois operandos) como +, - e *, devemos colocar um espa√ßo em cada lado do operador. N√£o queremos escrever um c√≥digo como este:\n1/11+4-3/2 Adicionar espa√ßos torna tudo muito mais f√°cil de ler:\n1 / 11 + 4 - 3 / 2 No entanto, √†s vezes pode ser apropriado abrir m√£o desse espa√ßo para agrupar as opera√ß√µes. Por exemplo, assim:\n1/11 + 4 - 3/2 Agrupar as opera√ß√µes dessa forma ajuda a lembrar os leitores da ordem das opera√ß√µes, deixando claro que n√£o estamos lidando com algo como 1 / (11 + 4).\nExerc√≠cios Agora que j√° lemos o material desta aula, aqui est√£o alguns exerc√≠cios para que voc√™ possa praticar:\n  Imprima sua idade no console.\n  Calcule e imprima o n√∫mero de dias, semanas e meses em 27 anos. N√£o se preocupe com anos bissextos!\n  Calcule e imprima a √°rea de um c√≠rculo com um raio de 5 unidades. Voc√™ pode ser t√£o preciso quanto quiser com o valor de pi.\n  Como parte deste exerc√≠cio, voc√™ pode querer ver quais outros operadores est√£o dispon√≠veis para n√≥s em Python.\n"
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula02/",
	"title": "2. Strings, Vari√°veis, e obtendo entrada de dados",
	"tags": [],
	"description": "",
	"content": " No√ß√µes b√°sicas de strings (texto) Vari√°veis: dando nome aos bois!  Lendo valores das variaveis   Obtendo valores do usu√°rio Exerc√≠cios  Nesta aula vamos falar sobre como usar strings, obter a entrada do usu√°rio e nomear valores em nossos programas usando vari√°veis.\nSe voc√™ perdeu a aula 1, recomendo dar uma olhada, caso n√£o se sinta confort√°vel com algum dos itens a seguir:\n Inteiros Floats Operadores aritm√©ticos simples (+ , -, / e *) A fun√ß√£o print O que s√£o express√µes  No√ß√µes b√°sicas de strings (texto) Strings em Python s√£o sequ√™ncias ordenadas de zero ou mais caracteres e podemos us√°-las para representar um conjunto de s√≠mbolos. Podem ser palavras, frases inteiras ou sequ√™ncias aleat√≥rias de letras, n√∫meros e pontua√ß√£o.\nPara criar uma string, s√≥ precisamos colocar algumas s√©ries de caracteres entre aspas:\n\u0026#34;Isso √© uma string!\u0026#34; Podemos utilizar aspas duplas ou simples. Para o Python tanto faz! E n√£o h√° raz√£o espec√≠fica para utilizar um ou o outo.\n\u0026#39;Isso tamb√©m √© uma string v√°lida\u0026#39; ‚ö†Ô∏è Por√©m n√£o podemos come√ßar nosso texto um tipo de aspas e terminar com outra.\n\u0026#34;Isto n√£o √© uma string v√°lida\u0026#39; Imprimir strings (texto) funciona exatamente como utilizamos com n√∫meros. N√≥s apenas precisamos passar o valor para a fun√ß√£o print:\nprint(\u0026#34;Ol√° mundo!\u0026#34;) Vari√°veis: dando nome aos bois! Uma ferramenta vital que estamos perdendo no momento √© uma forma de nos referirmos aos valores que calculamos. Lembre-se de que podemos escrever express√µes como 45 + 56, e o Python faz esse c√°lculo, embora n√£o tenhamos imprimido nada no console. A quest√£o √©: como nos referimos ao resultado dessa express√£o?\nAcontece que podemos nomear valores em Python usando uma opera√ß√£o de atribui√ß√£o. A sintaxe para vincular um valor a um nome √© relativamente simples. Precisamos apenas escrever o nome que queremos usar, um s√≠mbolo = e a express√£o ou valor que ser√° atribu√≠do a este nome. Este nome √© denominado vari√°vel.\nAqui est√£o alguns exemplos:\nnome = \u0026#34;S√≥crates\u0026#34; idade = 28 Os nomes de vari√°veis que escolhemos dependem inteiramente de n√≥s, mas existem algumas regras que precisamos ter em mente:\n Os nomes das vari√°veis podem incluir letras, n√∫meros e caracteres de sublinhado (_). Os nomes das vari√°veis n√£o podem come√ßar com um n√∫mero, embora seja permitido come√ßar com um sublinhado. Os nomes das vari√°veis diferenciam mai√∫sculas de min√∫sculas.  Essas limita√ß√µes significam que todos os seguintes nomes de vari√°veis s√£o inv√°lidos:\n1st_value nome-sobrenome joaquim\u0026#39;s_age exemplo de variavel   1st_value n√£o √© permitido porque come√ßa com um n√∫mero.\n  nome-sobrenome cont√©m um h√≠fen (-), que n√£o √© permitido.\n  joaquim's_age n√£o √© permitido porque possui um ap√≥strofo.\n  exemplo de variavel possui espa√ßos, o que tamb√©m n√£o √© permitido.\n  Essas regras fazem muito sentido. Por exemplo, se os n√∫meros fossem permitidos como o primeiro caractere de um nome de vari√°vel, poder√≠amos usar nomes de caractere √∫nico como 4. No entanto, tamb√©m √© assim que criamos um n√∫mero inteiro e pode levar a confus√£o.\nDa mesma forma, o sobre-nome cont√©m um caractere -, que entra em conflito com o operador - para subtra√ß√£o, e joaquim's_age tem um problema semelhante com o ', que √© usado para definir strings.\nUm nome de vari√°vel v√°lido que pode surpreend√™-lo √© _. Este √© um caso de uso especial que abordaremos posteriormente na s√©rie.\nSe quisermos definir nomes de vari√°veis com v√°rias palavras, podemos separar essas palavras com um sublinhado, assim:\nnome = \u0026#34;Leonel\u0026#34; sobrenome = \u0026#34;Messi\u0026#34; Lendo valores das variaveis Agora que sabemos como vincular valores a nomes, a pr√≥xima etapa √© aprender como recuperar esses valores de nossas vari√°veis. A boa not√≠cia √© que isso √© extremamente simples. Tudo o que temos a fazer √© escrever o nome da vari√°vel onde queremos usar o valor.\nPor exemplo, podemos escrever algo assim:\nvalor_hora = 20.00 horas_trabalhadas = 40 print(valor_hora * horas_trabalhadas) Aqui, definimos duas vari√°veis valor_hora, que √© um float, e horas_trabalhadas, que √© um n√∫mero inteiro. Em seguida, nos referimos aos valores e os usamos como operandos para o operador *.\nSe executarmos o c√≥digo acima, veremos 800.00 impresso na tela. Lembre-se de que multiplicar qualquer n√∫mero por um float resulta em um float.\nPor acaso, referir-se a um nome de vari√°vel √© outro tipo de express√£o. Quando escrevemos um nome de vari√°vel em qualquer lugar de nosso c√≥digo, ele √© avaliado como o valor que associamos a esse nome.\nObtendo valores do usu√°rio At√© agora, fornecemos todos os valores em nosso c√≥digo Python, mas √†s vezes precisamos obter valores do usu√°rio. Por exemplo, talvez queiramos saber o nome e a idade do usu√°rio.\nFelizmente, n√£o precisamos implementar algo assim do zero, porque o Python vem com outra fun√ß√£o para fazer exatamente esse trabalho. Esta fun√ß√£o √© chamada de input.\nChamamos input exatamente da mesma maneira que print, s√≥ precisamos escrever o nome da fun√ß√£o e colocar os par√™nteses de abertura e fechamento logo ap√≥s:\ninput() Se voc√™ executar o c√≥digo acima, n√£o ver√° nada no console, mas se olhar o bot√£o ‚ÄúRun‚Äù no repl.it, ver√° que diz ‚ÄúStop‚Äù. Isso significa que o programa ainda est√° em execu√ß√£o. Voc√™ tamb√©m descobrir√° que pode digitar no console.\nSe voc√™ pressionar Enter, o programa ser√° encerrado. Isso ocorre porque quando voc√™ pressiona enter, a fun√ß√£o de entrada vai parar de aceitar a entrada do usu√°rio. Como n√£o temos nenhum outro c√≥digo em nosso programa, Python ent√£o fica sem c√≥digo para executar e termina o programa.\nEmbora possamos chamar a entrada de dados apenas escrevendo input(), normalmente vamos fornecer algum tipo de prompt (texto), para que o usu√°rio saiba o que queremos deles. Seu primeiro instinto pode ser fazer algo assim:\nprint(\u0026#34;Qual o seu nome?: \u0026#34;) input() Isso certamente funcionar√°, mas a entrada √© realmente capaz de fornecer seu pr√≥prio texto. Precisamos apenas escrever o texto desejado entre par√™nteses quando chamamos a fun√ß√£o:\ninput(\u0026#34;Qual o seu nome?: \u0026#34;) A √∫ltima pe√ßa do quebra-cabe√ßa √© armazenar esse valor em algum lugar. Lembre-se de que as chamadas de fun√ß√£o s√£o express√µes e, portanto, elas geram algum valor. A fun√ß√£o input √© avaliada como uma string que cont√©m tudo o que o usu√°rio escreveu em resposta ao prompt. Podemos, portanto, atribuir esta string a uma vari√°vel se quisermos, assim:\nnome = input(\u0026#34;Qual o seu nome? \u0026#34;) Se voc√™ digitar Manoel, a vari√°vel nome ter√° gravado em mem√≥ria o nome \u0026quot;Manoel\u0026quot; como uma string.\nExerc√≠cios Agora que sabemos como usar strings, vari√°veis e a fun√ß√£o de entrada (input), √© hora de praticar alguns exerc√≠cios.\n Pergunte ao usu√°rio o nome e a idade, atribua esses valores a duas vari√°veis e, em seguida, imprima-os. Investigue o que acontece quando voc√™ tenta atribuir um valor a uma vari√°vel que voc√™ j√° definiu. Tente imprimir a vari√°vel antes e depois de reutilizar o nome. Abaixo, voc√™ encontrar√° alguns c√≥digos com v√°rios erros. Tente percorrer o programa linha por linha e corrigir os problemas no c√≥digo. Recomendo que voc√™ tente executar o programa enquanto est√° trabalhando nele, pois ler as mensagens de erro √© uma √≥tima pr√°tica para depurar seus pr√≥prios programas.  valor_hora = input(\u0026#34;Digite o valor da sua hora de trabalho: \u0026#39;) prnt(\u0026#34;Valor hora: \u0026#34;) print(valorhora) print(\u0026#34;Horas trabalhadas: \u0026#34;) print(horas_trabalhadas) horas_trabalhadas = input(\u0026#34;Quantas horas voc√™ trabalhou esta semana? \u0026#34;) "
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula03/",
	"title": "3. Formatando Strings e Processando Entrada do Usu√°rio",
	"tags": [],
	"description": "",
	"content": " Concatena√ß√£o de string Convertendo strings, inteiros e floats Interpola√ß√£o de strings com o m√©todo format Coment√°rios Processamento b√°sico de strings  Processando m√∫ltiplas linhas   Exerc√≠cios  Nesta vamos falar sobre concatenar strings (juntar strings), interpola√ß√£o de strings (colocar valores dentro de strings) e processar a entrada do usu√°rio. Tamb√©m vamos falar sobre como podemos documentar melhor nosso c√≥digo usando coment√°rios.\nConcatena√ß√£o de string Vamos come√ßar com o reasultado do exerc√≠cio da aula anterior:\nvalor_hora = input(\u0026#34;Digite o valor da sua hora de trabalho: \u0026#34;) horas_trabalhadas = input(\u0026#34;Quantas horas voc√™ trabalhou esta semana? \u0026#34;) print(\u0026#34;Valor hora: \u0026#34;) print(valor_hora) print(\u0026#34;Horas trabalhadas: \u0026#34;) print(horas_trabalhadas) Aqui, pedimos ao usu√°rio duas informa√ß√µes e, em seguida, imprimimos essas informa√ß√µes de volta no console junto com alguns cabe√ßalhos.\nIsso √© muito bom, mas n√£o seria bom se pud√©ssemos ter o valor valor_hora na mesma linha que o r√≥tulo \u0026quot;Valor hora: \u0026quot;? √â aqui que entra a concatena√ß√£o de strings (juntando duas ou mais strings).\nConcatenar coisas significa juntar ou ligar coisas, e √© isso que queremos fazer com nossas strings. Queremos pegar a string, \u0026quot;Valor hora: \u0026quot;, e queremos juntar a ela a string que atribu√≠mos √† vari√°vel,valor_hora.\nEm Python, podemos apenas usar o operador + para isso, assim:\nvalor_hora = input(\u0026#34;Digite o valor da sua hora de trabalho: \u0026#34;) horas_trabalhadas = input(\u0026#34;Quantas horas voc√™ trabalhou esta semana? \u0026#34;) print(\u0026#34;Valor hora: \u0026#34; + valor_hora) print(\u0026#34;Horas trabalhadas: \u0026#34; + horas_trabalhadas) Muito parecido com quando usamos + para somar n√∫meros, podemos encadear quantas strings quisermos usando +. No entanto, devemos ter muito cuidado para n√£o combinar os tipos.\nPor exemplo, n√£o podemos fazer algo assim, em que tentamos juntar um inteiro em uma string:\nprint(\u0026#34;Valor hora: \u0026#34; + valor_hora) Se executarmos este programa, o Python retornar√° o seguinte erro:\nDesta vez, obtemos um TypeError, que nos diz que tentamos concatenar um int (inteiro) em uma str (string), mas esta opera√ß√£o s√≥ √© suportada entre strings.\nPortanto, a quest√£o agora √©: o que faremos se precisarmos realizar algumas opera√ß√µes aritm√©ticas e, em seguida, colocar o resultado em uma string? Felizmente, o Python nos fornece algumas ferramentas para converter valores de um tipo em outro.\nConvertendo strings, inteiros e floats Primeiro, vamos falar sobre a convers√£o de inteiros e flutuantes em strings. A ferramenta que usaremos √© a chamada str, e podemos pensar nela como sendo muito parecida com uma fun√ß√£o.\nQuando chamamos str, passando um inteiro ou um float, vamos obter uma nova string contendo os numerais que comp√µem o n√∫mero, junto com as casas decimais no caso de floats.\nPor exemplo, podemos escrever algo assim:\nidade = str(12) O que vai atribuir √† idade a mesma coisa que se escrev√™ssemos:\nidade = \u0026#34;12\u0026#34; Converter de uma string em um inteiro ou float √© um pouco mais complicado, porque nem toda string √© um n√∫mero v√°lido. Al√©m disso, mesmo se uma string for um n√∫mero v√°lido, pode n√£o ser um n√∫mero v√°lido do tipo para o qual estamos tentando converter.\nSe quisermos converter uma string em um inteiro, precisamos chamar int, passando a string. Os caracteres da string devem representar um n√∫mero inteiro.\nidade = int(\u0026#34;12\u0026#34;) ‚ö†Ô∏è Se tentarmos passar uma representa√ß√£o de string de um n√∫mero com casas decimais, vamos obter um TypeError. Por exemplo, algo assim:\nvalor_hora = int(\u0026#34;20.53\u0026#34;) ‚ö†Ô∏è Ao executar retornar√° a seguinte mensagem de erro:\nTraceback (most recent call last): File \u0026#34;main.py\u0026#34;, line 1, in \u0026lt;module\u0026gt; int(\u0026#34;20.53\u0026#34;) ValueError: invalid literal for int() with base 10: \u0026#39;20.53\u0026#39; Ao inv√©s de int, necessitamos chamar float:\nvalor_hora = float(\u0026quot;20.53\u0026quot;) ‚úîÔ∏è float tamb√©m pode manipular a entrada sem um componente decimal. Por exemplo, se passarmos \u0026quot;20\u0026quot;, vamos obt√™-lo com casas decimais 20.0 de volta.\nAl√©m de converter de strings em inteiros e flutuantes, e vice-versa, tamb√©m podemos converter entre inteiros e flutuantes usando o mesmo int e float. Neste caso, passar um float para int vai funcionar, mas vai \u0026ldquo;truncar\u0026rdquo; o float, essencialmente jogando fora tudo ap√≥s a v√≠rgula decimal.\nTruncamento √© o ato de encurtar algo removendo alguma parte dele. Por exemplo, podemos nos referir a truncar um float, o que significa que estamos removendo tudo ap√≥s o ponto decimal.\nInterpola√ß√£o de strings com o m√©todo format A concatena√ß√£o de strings √© uma coisa √∫til de se saber, mas √© um pouco desajeitada e est√° sujeita a erros de espa√ßamento, como vimos. Uma abordagem melhor costuma ser usar a interpola√ß√£o de strings, especialmente ao trabalhar com conte√∫do que tem uma estrutura semelhante a uma frase.\nA interpola√ß√£o de string √© o ato de inserir algum conte√∫do novo em uma string existente.\nAo contr√°rio da concatena√ß√£o, a interpola√ß√£o depende de colocarmos marcadores em uma string que podemos preencher com valores. Isso torna muito mais dif√≠cil cair em problemas de formata√ß√£o, porque os marcadores de posi√ß√£o est√£o na posi√ß√£o exata que os valores ir√£o ocupar. Outro grande benef√≠cio da interpola√ß√£o: n√£o precisamos nos preocupar com os tipos! Python ir√° garantir que obteremos uma representa√ß√£o de string de todos os nossos valores.\nExistem v√°rias maneiras de realizar a interpola√ß√£o de string em Python, mas primeiro veremos como usar o m√©todo de formata√ß√£o format.\nO m√©todo format possu√≠ diversas formas de ser utilizado, utilizaremos a forma simplificada dele. üòâ\nAo usar o m√©todo format, os marcadores de posi√ß√£o para nossos valores s√£o chaves, que se parecem com isto: {}. Por exemplo, digamos que queremos escrever uma string como:\n\u0026#34;Tiago tem 35 anos!\u0026#34; Mas em vez de apenas \u0026quot;Tiago\u0026quot; e \u0026quot;35\u0026quot;, queremos ser capazes de escrever qualquer nome e qualquer idade aqui. Tudo o que temos que fazer √© substituir \u0026quot;Tiago\u0026quot; e \u0026quot;35\u0026quot; por chaves, assim:\nf\u0026#34;{}tem {}anos!\u0026#34; Usando este exemplo, nosso programa ficaria assim:\nnome = \u0026#34;Tiago\u0026#34; idade = 35 print(f\u0026#34;{nome}tem {idade}anos!\u0026#34;) Podemos tamb√©m utilizar o m√©todo para escrever express√µes dentro dentro dele:\nnome = \u0026#34;Tiago\u0026#34; idade = 35 print(f\u0026#34;{nome}tem {idade*12}meses de idade!\u0026#34;) Coment√°rios Usando nomes bons e descritivos, podemos fazer muito para tornar nosso c√≥digo autodocumentado; no entanto, √†s vezes, mesmo um bom c√≥digo pode ser dif√≠cil de entender. Afinal, algumas coisas s√£o complicadas.\nEm casos como este, pode ser √∫til usar coment√°rios para explicar aos leitores de nosso c√≥digo (o que nos inclui) o que o c√≥digo est√° fazendo.\nPara escrever um coment√°rio, s√≥ precisamos colocar um # diretamente antes da mensagem que queremos escrever. Isso dir√° ao Python para n√£o tratar o que se segue como c√≥digo.\nnome = \u0026#34;Tiago\u0026#34; idade = 35 #Imprime a idade em meses print(f\u0026#34;{nome}tem {idade*12}meses de idade!\u0026#34;) Tente n√£o exagerar nos coment√°rios, pois coment√°rios em todas as linhas podem causar mais danos do que benef√≠cios no que diz respeito √† legibilidade.\nProcessamento b√°sico de strings A √∫ltima coisa que √© bom mencionar nesta aula s√£o algumas opera√ß√µes comuns de processamento de strings, como alterar a caixa das letras ou remover espa√ßos em branco (caracteres de espa√ßo, tabula√ß√µes, novas linhas, etc.) das extremidades das strings. Esse tipo de coisa acontece o tempo todo quando lidamos com a entrada do usu√°rio.\nTemos v√°rias op√ß√µes diferentes para alterar a caixa das letras em uma string. Aqui, vamos nos concentrar em quatro op√ß√µes importantes: lower, upper, capitalize e title.\nlower e upper transformam a string inteira em min√∫sculas e mai√∫sculas, respectivamente. Os caracteres que n√£o possuem mai√∫sculas e min√∫sculas, como caracteres de pontua√ß√£o, s√£o ignorados.\ncapitalize vai transformar o primeiro caractere em mai√∫sculas, com o resto em min√∫sculas. title vai transformar a string em mai√∫sculas, o que significa que cada palavra come√ßa com uma letra mai√∫scula e todas as outras letras s√£o transformadas em min√∫sculas.\nPara utilzar estes m√©todos, escrevemos da seguinte forma:\n\u0026#34;Ol√°, Mundo!\u0026#34;.lower() # \u0026#34;ola, mundo!\u0026#34; \u0026#34;Ol√°, Mundo!\u0026#34;.upper() # \u0026#34;OL√Å, MUNDO!\u0026#34; \u0026#34;Ol√°, Mundo!\u0026#34;.capitalize() # \u0026#34;Ol√°, mundo!\u0026#34; \u0026#34;Ol√°, Mundo!\u0026#34;.title() # \u0026#34;Ol√°, Mundo!\u0026#34; Em cada caso, estamos escrevendo uma express√£o, e o valor dessa express√£o √© uma nova string no caso solicitado.\nN√£o h√° muito mais a fazer quando se trata de mudar de caixa, mas que tal remover o espa√ßo em branco no fim das strings? Para isso, podemos usar o m√©todo strip.\nstrip √© na verdade muito mais vers√°til do que isso, e podemos fazer com que ele remova qualquer coisa que quisermos, mas por padr√£o ele nos dar√° uma string nova com qualquer espa√ßo em branco estranho removido de ambas as extremidades.\nN√≥s o usamos exatamente da mesma maneira que lower, upper, etc.\n\u0026#34; Ol√°, Mundo! \u0026#34;.strip() # \u0026#34;Ol√°, Mundo!\u0026#34; Perceba no exemplo acima como os espa√ßos das extremidade s√£o removidas.\nProcessando m√∫ltiplas linhas Podemos aplicar v√°rios m√©todos de processamento a uma string. Deixe-me mostrar duas maneiras de fazer isso.\nA primeira forma envolve a cria√ß√£o de uma vari√°vel e a reatribui√ß√£o a ela para cada chamada de m√©todo, assim:\nuser_name = \u0026#34; ANA OLIVEIRA \u0026#34; user_name = user_name.strip() # \u0026#34;ANA OLIVEIRA\u0026#34; user_name = user_name.title() # \u0026#34;Ana Oliveira\u0026#34; Embora isso seja muito repetitivo, e reatribuir a uma vari√°vel v√°rias vezes geralmente pare√ßa ineficiente (embora n√£o seja lento, Python pode reatribuir a vari√°veis muito rapidamente).\nPortanto, a segunda maneira de fazer isso envolve usar o resultado de cada etapa em linha, assim:\nuser_name = \u0026#34; ANA OLIVEIRA \u0026#34;.strip().title() Aprenderemos mais sobre como isso funciona exatamente quando examinarmos as fun√ß√µes e os valores de retorno, mas por enquanto tratamos cada chamada de m√©todo, como \u0026quot;ANA OLIVEIRA\u0026quot;.strip(), como a string que ela devolveria a voc√™.\nExerc√≠cios  Utilizando a vari√°vel abaixo, imprima \u0026quot;Ol√° , mundo!\u0026quot;:  saudacao = \u0026#34;Ol√°, mundo\u0026#34; Voc√™ pode adicionar o ponto de exclama√ß√£o ausente usando concatena√ß√£o de string ou format. A escolha √© sua.\n Pe√ßa o nome do usu√°rio e, em seguida, cumprimente-o, usando o nome dele como parte da sauda√ß√£o. O nome deve estar em caixa do t√≠tulo (title) e n√£o deve ser circundado por nenhum espa√ßo em branco.\nPor exemplo, se o usu√°rio digitar \u0026ldquo;eduardo\u0026rdquo;, sua sa√≠da deve ser algo assim:\nOl√°, Eduardo!   Concatene a string \u0026quot;Eu tenho\u0026quot; , inteiro 48, e novamente outra string \u0026quot;anos.\u0026quot; para pruduzir uma string \u0026quot;Eu tenho 48 anos.\u0026quot; Lembre-se de que s√≥ podemos concatenar strings para outras strings, portanto, voc√™ ter√° que converter o inteiro em uma string antes de realizar a concatena√ß√£o.\n  Formate e imprima as informa√ß√µes abaixo utilizando interpola√ß√£o de strings:]\ntitulo = \u0026#34;O Coringa\u0026#34; diretor = \u0026#34;Todd Phillips\u0026#34; ano = 2019 O resultado deve parecer como o abaixo:\nO Coringa (2019), dirigido por Todd Phillips.   "
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula04/",
	"title": "4. Cole√ß√µes - Listas e Tuplas",
	"tags": [],
	"description": "",
	"content": " Listas  Acessando valores em uma lista Adicionando itens a lista Removendo itens de uma lista   Tuplas  Acessando valores em uma tupla Tuplas vs Listas   Acessando valores em cole√ß√µes aninhadas Exerc√≠cios  Listas A primeira nova cole√ß√£o que veremos s√£o as listas.\nSimplificando, as listas s√£o cont√™ineres para outros valores. Ao contr√°rio das strings, que s√£o cole√ß√µes apenas de caracteres, as listas podem armazenar quaisquer valores que desejemos. Podemos at√© misturar diferentes tipos de valores, se quisermos.\nDefinimos uma lista usando colchetes como este:\nnomes = [\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] Cada valor √© colocado entre colchetes, separados por v√≠rgulas.\nNesse caso, definimos uma lista em uma linha. Aqui est√° tudo bem, mas √†s vezes pode ficar um pouco dif√≠cil de ler. Por exemplo, e se estivermos tentando armazenar uma lista de t√≠tulos de filmes e tivermos strings como \u0026quot;Tropa de Elie 2 - O Inimigo Agora √© Outro\u0026quot;? Muito rapidamente, acabaremos com um c√≥digo excedendo a largura de nossas telas. O mesmo se aplica se tivermos muitos e muitos valores.\nQuando nos deparamos com uma situa√ß√£o como esta, podemos dividir a lista em v√°rias linhas da seguinte forma:\nfilmes = [\u0026#34;Tropa de Elite 2 - O Inimigo Agora √© Outro\u0026#34;, \u0026#34;Austin Powers 2\u0026#34;, \u0026#34;O Auto da Compadecida\u0026#34;] Como mencionei anteriormente, podemos misturar qualquer tipo de valor que quisermos em uma lista, voc√™ n√£o precisa ter apenas strings ou apenas inteiros.\nrei = [\u0026#34;Edson Arantes do Nascimento\u0026#34;, 80, \u0026#34;Jogador de Futebol\u0026#34;] Tamb√©m √© poss√≠vel definir uma lista sem conte√∫do, que √© representada por um par vazio de colchetes [].\nPodemos imprimir na tela uma lista inteira apenas passando-a a fun√ß√£o print, como abaixo:\nrei = [\u0026#34;Edson Arantes do Nascimento\u0026#34;, 80, \u0026#34;Jogador de Futebol\u0026#34;] print(rei) No entanto, geralmente estamos interessados nos valores dentro de uma lista, e n√£o na lista como um todo, ent√£o vamos ver como acessar os valores da lista.\nAcessando valores em uma lista Cada valor em uma lista √© indexado de acordo com sua posi√ß√£o na lista. O item na primeira posi√ß√£o est√° no √≠ndice 0; o item na segunda posi√ß√£o est√° no √≠ndice 1; e assim por diante.\nPodemos acessar valores em uma lista usando esses √≠ndices, e geralmente fazemos isso com uma parte da sintaxe chamada express√£o de assinatura.\nExpress√µes de assinatura s√£o usadas para acessar valores em muitas cole√ß√µes. Para sequ√™ncias, eles s√£o usados para acessar elementos por √≠ndice.\n√â mais ou menos assim:\nnomes = [\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] print(nomes[1]) #Alice Para recuperar o valor Alice dos nomes, escrevemos o nome da lista que desejamos acessar e, em seguida, dentro de alguns colchetes, colocamos o √≠ndice do item que desejamos recuperar.\nTamb√©m √© poss√≠vel se referir a um √≠ndice negativo, o que nos permite trabalhar a partir do final da lista. Nesse caso, o item no √≠ndice -1 √© o √∫ltimo item; o item como √≠ndice -2 √© o pen√∫ltimo item; e assim por diante.\nnomes = [\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] print(nomes[-1]) #Tiago Isso pode ser muito √∫til quando queremos o item final de uma lista, pois nos poupa ter que fazer c√°lculos para descobrir o √≠ndice do item final.\nAdicionando itens a lista Uma caracter√≠stica interessante das listas √© que elas s√£o mut√°veis: podemos alterar os valores internos. Isso significa que podemos adicionar valores, remov√™-los, substitu√≠-los, reorden√°-los, etc.\nPrimeiro, vamos nos concentrar em adicionar itens a uma lista usando o m√©todo append. Como o nome pode sugerir, append nos permite adicionar um item ao final de uma lista. Mais uma vez, precisamos usar a nota√ß√£o de ponto para chamar append e colocamos o valor que queremos adicionar entre par√™nteses quando o chamamos.\nnomes = [\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] nomes.append(\u0026#34;Evelin\u0026#34;) print(nomes[-1]) #Evelin Tamb√©m podemos adicionar outro item (ou itens) a uma lista usando o operador +. Nesse caso, ambos os operandos devem ser listas.\nA abordagem tamb√©m √© um pouco diferente, pois temos que realizar uma atribui√ß√£o como parte da opera√ß√£o.\nnomes = [\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] nomes = nomes + [\u0026#39;Evelin\u0026#39;] print(nomes[-1]) #Evelin Isso √†s vezes pode ser √∫til, porque n√£o modifica a lista original, j√° que a opera√ß√£o produz uma nova lista. append, por outro lado, modifica a lista existente.\nAl√©m do m√©todo append e do operador +, tamb√©m temos um m√©todo chamado extend, que nos permite adicionar v√°rios itens ao final de uma lista existente.\nTodos s√£o √≥timos para adicionar um item ao final de uma lista, mas e se quisermos adicionar um item no meio? Para isso, temos o m√©todo insert.\ninsert √© um pouco mais complicado do que as op√ß√µes que vimos at√© agora, pois precisa de duas informa√ß√µes. Primeiro, precisamos dizer onde queremos inserir o valor e, segundo, precisamos dizer o que queremos inserir.\nPor exemplo, digamos que temos uma lista como esta:\nnumeros = [1, 2, 4, 5] No momento, estamos perdendo o valor 3 nesta sequ√™ncia e queremos inserir esse valor no √≠ndice 2. Portanto, precisamos chamar o insert desta forma:\nnumeros = [1, 2, 4, 5] numeros.insert(2, 3) print(numeros) #[1,2,3,4,5] Como voc√™ pode ver, os outros valores foram misturados corretamente para abrir espa√ßo para nossa nova adi√ß√£o.\nUma coisa que voc√™ pode estar se perguntando √©: o que acontece se especificarmos um √≠ndice fora da lista definida? Em vez disso, Python apenas coloca o item como o final:\nnumeros = [1, 2, 4, 5] numeros.insert(7, 3) print(numeros) #[1,2,3,4,5] Removendo itens de uma lista Assim como na adi√ß√£o de itens, existem v√°rias op√ß√µes dispon√≠veis para uso quando se trata de remover itens de uma lista.\nPrimeiro, temos o m√©todo remove. remove mais uma vez usa a sintaxe de ponto que vimos v√°rias vezes agora e remove o primeiro item que corresponde ao valor que passamos.\nPor exemplo, se tivermos uma lista como esta:\nnomes = [\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] Podemos remover o primeiro nome Jo√£o chamando remove:\nnomes = [\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] nomes.remove(\u0026#34;Jo√£o\u0026#34;) print(names) #[\u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] A segunda inst√¢ncia de \u0026quot;Jo√£o\u0026quot; √© deixada intacta e tudo muda para a esquerda para que n√£o tenhamos um buraco em nossa lista.\n√Äs vezes, n√£o sabemos necessariamente o valor que queremos remover, mas sabemos onde o valor est√° em nossa lista. Em casos como esse, temos algumas op√ß√µes.\nPrimeiro, podemos usar a palavra-chave del. del pode ser usado para excluir qualquer coisa que quisermos, incluindo uma lista inteira, mas se usarmos uma express√£o de assinatura, podemos us√°-la para remover um item em um √≠ndice espec√≠fico.\nnomes = [\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] del nomes[2] print(names) #[\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Tiago\u0026#34;] A principal alternativa que temos para usar del √© pop. Por padr√£o, o pop remover√° o √∫ltimo item da lista, mas podemos opcionalmente passar um √≠ndice como um argumento para remover um item diferente.\nnomes = [\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] nomes.pop() print(nomes) #[\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;] nomes.pop(1) print(nomes) #[\u0026#34;Jo√£o\u0026#34;, \u0026#34;Sarah\u0026#34;] Uma das coisas realmente √∫teis sobre pop √© que a express√£o de chamada do m√©todo avalia o item que removemos da lista. Podemos, portanto, usar isso para remover um item que planejamos usar para alguma opera√ß√£o futura:\nnomes = [\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] ultimo_da_lista = nomes.pop() print(nomes) #[\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;] print(ultimo_da_lista) #Tiago Finalmente, temos o clear. Este √© muito simples, ele apenas remover√° tudo dentro de uma determinada lista:\nnomes = [\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;] nomes.clear() print(nomes) #[] Tuplas As tuplas s√£o como listas, por√©m s√£o valores nas quais n√£o iremos alterar, s√£o imut√°veis. Exemplo, a largura e altura da janela de um jogo. Assim definimos estes padr√µes e elas n√£o ser√£o alteradas.\nTudo o que precisamos para definir uma tupla √© uma s√©rie de valores separados por v√≠rgulas:\nnomes = \u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34; Mais frequentemente, no entanto, veremos tuplas escritas assim:\nnomes = (\u0026#34;Jo√£o\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Tiago\u0026#34;) Na maioria das vezes, esses par√™nteses s√£o opcionais - s√£o as v√≠rgulas que s√£o importantes - mas h√° casos em que realmente precisamos deles para distinguir o conte√∫do da tupla de outros valores separados por v√≠rgula.\nPor exemplo, √© totalmente legal (e comum) colocar tuplas em uma lista. Talvez queiramos armazenar nomes de filmes e datas de lan√ßamento juntos em uma lista de filmes como esta:\nfilmes = [(\u0026#34;Tropa de Elite 2 - O Inimigo Agora √© Outro\u0026#34;, 2010), (\u0026#34;Austin Powers 2\u0026#34;, 1999), (\u0026#34;O Auto da Compadecida\u0026#34;, 2000)] Acessando valores em uma tupla Muito parecido com as listas, as tuplas s√£o cole√ß√µes ordenadas, onde cada item pode ser acessado por √≠ndice com base em sua posi√ß√£o na cole√ß√£o.\nAt√© usamos a mesma sintaxe de express√£o de assinatura para acessar itens em uma tupla.\nTuplas vs Listas Uma das grandes diferen√ßas entre tuplas e listas √© que as tuplas s√£o imut√°veis. N√£o podemos mud√°-los, uma vez que os definimos.\nIsso significa que voc√™ n√£o encontrar√° nenhum m√©todo pop ou append para tuplas, e a fun√ß√£o del n√£o permitir√° que voc√™ remova valores usando um √≠ndice.\nUma coisa que funcionar√° √© o operador +, mas se nos lembrarmos de nossa discuss√£o de + com listas, esse operador nos d√° uma nova cole√ß√£o. Se o usarmos com uma tupla, a tupla original permanecer√° inalterada: acabamos de criar uma nova.\nObserve que voc√™ s√≥ pode usar + para juntar duas tuplas.\nO fato de que as tuplas n√£o podem mudar √© uma propriedade muito desej√°vel, porque nos permite definir uma estrutura consistente para seus conte√∫dos, o que significa que usamos os valores como c√©lulas em uma linha de tabela. Deixe-me mostrar o que quero dizer.\nDigamos que temos tr√™s informa√ß√µes que queremos armazenar para cada filme de nossas cole√ß√µes. Queremos o t√≠tulo do filme, o nome do diretor e o ano de lan√ßamento.\nPosso definir minha cole√ß√£o de filmes assim:\nfilmes = [ ( \u0026#34;Tropa de Elite 2 - O Inimigo Agora √© Outro\u0026#34;, \u0026#34;Jos√© Padilha\u0026#34;, 2010 ), ( \u0026#34;Austin Powers 2\u0026#34;, \u0026#34;Jay Roach\u0026#34;, 1999 ), ( \u0026#34;O Auto da Compadecida\u0026#34;, \u0026#34;Guel Arraes\u0026#34;, 2000 )] Acessando valores em cole√ß√µes aninhadas Agora temos algumas inst√¢ncias de cole√ß√µes aninhadas - tuplas dentro de uma lista, por exemplo - ent√£o precisamos falar brevemente sobre como obter itens dessas cole√ß√µes internas.\nLembre-se de que quando escrevemos algo como minha_lista [0], esta √© uma express√£o de inscri√ß√£o. O valor que ele nos fornece √© o valor no √≠ndice solicitado na cole√ß√£o que especificamos.\nPortanto, se tivermos uma cole√ß√£o como esta:\nfilmes = [(\u0026#34;Tropa de Elite 2 - O Inimigo Agora √© Outro\u0026#34;, 2010), (\u0026#34;Austin Powers 2\u0026#34;, 1999), (\u0026#34;O Auto da Compadecida\u0026#34;, 2000)] E solicitamos um valor:\nfilmes[0] Obtemos a primeira tupla da lista:\n(\u0026#34;Tropa de Elite 2 - O Inimigo Agora √© Outro\u0026#34;, 2010) Portanto, se quisermos o t√≠tulo deste filme, que sabemos estar no √≠ndice 0, podemos adicionar outro conjunto de colchetes como:\nfilmes[0][0] # \u0026#34;Tropa de Elite 2 - O Inimigo Agora √© Outro\u0026#34; Exerc√≠cios  Crie uma lista de filmes contendo uma √∫nica tupla. A tupla deve conter o t√≠tulo do filme, o nome do diretor, o ano de lan√ßamento do filme e o or√ßamento do filme. Use a fun√ß√£o input para coletar informa√ß√µes sobre outro filme. Voc√™ precisa de um t√≠tulo, nome do diretor, ano de lan√ßamento e or√ßamento. Crie uma nova tupla a partir dos valores que voc√™ reuniu usando a entrada. Certifique-se de que eles est√£o na mesma ordem que a tupla que voc√™ escreveu na lista de filmes. Use uma string f para imprimir o nome do filme e o ano de lan√ßamento, acessando sua nova tupla de filme. Adicione a nova tupla de filme √† cole√ß√£o de filmes usando append. Imprima ambos os filmes da cole√ß√£o de filmes. Remova o primeiro filme dos filmes. Use o m√©todo que desejar.  "
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula05/",
	"title": "5. Booleanos e Condicionais",
	"tags": [],
	"description": "",
	"content": " Valores verdadeiros Operadores de compara√ß√£o  Ordem das opera√ß√µes   Condicionais  Valores verdadeiros e condicionais   Exerc√≠cios  Antes de examinarmos os condicionais, primeiro precisamos aprender sobre um novo tipo chamado Booleanos. Os booleanos s√£o nomeados em homenagem ao matem√°tico George Boole, que definiu um sistema alg√©brico para determinar o valor de verdade de express√µes l√≥gicas.\nToda linguagem de programa√ß√£o moderna apresenta alguma representa√ß√£o de valores booleanos, porque muitas vezes precisamos ser capazes de declarar se algo √© ou n√£o √©.\nSempre temos apenas dois valores booleanos e, em Python, esses valores s√£o as palavras True (Verdadeiro) e False (Falso). A capitaliza√ß√£o √© importante aqui: True √© um valor booleano, enquanto TRUE e true n√£o s√£o.\n√â importante ressaltar que True tamb√©m n√£o √© a mesma coisa que a string \u0026quot;True\u0026quot;.\nPodemos usar esses valores booleanos como quaisquer outros valores que usamos em Python at√© agora. Podemos atribu√≠-los a vari√°veis e colocar booleanos em tuplas e listas.\nPor exemplo, talvez queiramos armazenar informa√ß√µes sobre alguns filmes na lista de observa√ß√£o de um usu√°rio. Podemos usar uma tupla para representar cada filme e podemos usar um booleano para representar se este filme foi ou n√£o visto por este usu√°rio:\nfilmes = [(\u0026#34;Tropa de Elite 2 - O Inimigo Agora √© Outro\u0026#34;, 2010, True), (\u0026#34;Austin Powers 2\u0026#34;, 1999, False), (\u0026#34;O Auto da Compadecida\u0026#34;, 2000, True)] Na lista de filmes acima, o √∫nico que n√£o assisti (False) √© Austin Powers 2.\nPodemos tamb√©m imprimir valores booleanos, a sa√≠da sempre ser√° True ou Falso.\nprint(True) #True print(False) #False Valores verdadeiros Cada valor em Python tem algum valor verdade associado. Isso pode ser um pouco estranho de se pensar no in√≠cio. N√£o √© particularmente intuitivo que \u0026quot;Ol√°!\u0026quot; esteja de alguma forma associado a True ou False, mas isso pode ser √∫til, como veremos em breve.\nPodemos encontrar o valor verdadeiro de qualquer valor em Python passando esse valor para a fun√ß√£o bool. bool retornar√° True ou False, dependendo do valor verdadeiro do que passamos.\nOs valores para os quais o bool retorna True s√£o freq√ºentemente chamados de valores verdadeiros, enquanto os valores para os quais o bool retorna False s√£o freq√ºentemente chamados de falsos.\nPor exemplo, se passarmos a string \u0026quot;Ol√°\u0026quot; para bool, a chamada da fun√ß√£o ser√° avaliada como True. \u0026quot;Ol√°\u0026quot; √©, portanto, um valor verdadeiro.\nprint (bool (\u0026#34;Ol√°!\u0026#34;)) # True Vemos ver outros exemplos:\nprint(bool(0)) # False print(bool(6)) # True print(bool(\u0026#34;Morumbi\u0026#34;)) # True print(bool(\u0026#34;\u0026#34;)) # False print(bool([])) # False print(bool([0, 1, 2, 3])) # True print(bool(True)) # True print(bool(False)) # False Como podemos ver, passar True ou False para bool nos d√° True e False respectivamente, mas n√£o parece haver muita rima ou raz√£o quando se trata dos outros valores.\nEmbora possa parecer basicamente aleat√≥rio, h√° de fato um padr√£o aqui. Apenas um pequeno n√∫mero de valores em Python s√£o falsos, que s√£o os seguintes:\n Qualquer representa√ß√£o num√©rica de zero. Isso inclui o inteiro 0, o flutuante 0,0 e representa√ß√µes de zero em outros tipos num√©ricos. Os valores False e None. Ainda n√£o vimos None, mas None representa a aus√™ncia intencional de um valor. Sequ√™ncias vazias e outras cole√ß√µes. Isso inclui strings vazias, tuplas vazias, listas vazias e v√°rios tipos que n√£o cobrimos neste est√°gio. Tamb√©m √© poss√≠vel definirmos nossos pr√≥prios tipos e podemos torn√°-los falsos em certas circunst√¢ncias, se desejarmos. Este √© um t√≥pico avan√ßado, no entanto, e n√£o algo que abordaremos nesta s√©rie.  Al√©m desses valores, tudo o mais em Python √© verdadeiro.\nOperadores de compara√ß√£o Al√©m da fun√ß√£o bool, temos v√°rios operadores de compara√ß√£o que geram um valor booleano. Temos oito deles no total, cinco dos quais voc√™ provavelmente j√° viu antes em uma aula de matem√°tica.\nPrimeiro, temos os operadores \u0026lt;(menor que) e \u0026gt; (maior que). No caso de \u0026lt;, o operador retorna o valor True se o primeiro operando for menor que o segundo operando; para \u0026gt;, o operador produz True se o primeiro operando for maior que o segundo operando.\nAlguns exemplos:\nprint(5 \u0026lt; 10) # True print(5 \u0026gt; 10) # False print(10 \u0026gt; 10) # False Muito semelhante a esses operadores, temos \u0026lt;= (menor ou igual a) e \u0026gt;= (maior ou igual a). Eles funcionam da mesma maneira que \u0026lt; e \u0026gt;, mas se os operandos forem de valor equivalente, obtemos True de volta em vez de False.\nprint(10 \u0026gt; 10) # False print(10 \u0026gt;= 10) # True Frequentemente, queremos verificar explicitamente se dois valores s√£o iguais. Nesse caso, podemos usar o operador ==. == retorna True se os dois valores s√£o iguais e False em todos os outros casos.\nTemos que ser um pouco cuidadosos aqui e lembrar que coisas como \u0026quot;0\u0026quot; n√£o s√£o iguais a 0. Python √© inteligente o suficiente para entender que algo como 7 e 7.0 s√£o equivalentes.\nprint(0 == \u0026#34;0\u0026#34;) # False print(0 == 0) # True print(7 == 7.0) # True print(\u0026#34;Ol√°\u0026#34; == \u0026#34;Ol√°!\u0026#34;) # False print([1, 2, 3] == [1, 2, 3]) # True Se quisermos verificar se dois valores n√£o s√£o iguais, temos um operador para isso tamb√©m, que se parece com este !=. Este ponto de exclama√ß√£o, √© comumente usado para significar \u0026quot;n√£o\u0026quot;. Portanto != significa simplesmente \u0026quot;diferente\u0026quot;.\nprint(0 != \u0026#34;0\u0026#34;) # True print(0 != 0) # False print(\u0026#34;Hello\u0026#34; != \u0026#34;Hi\u0026#34;) # True Os dois √∫ltimos que temos que olhar s√£o um pouco mais complicados, porque eles n√£o est√£o comparando os valores, por si s√≥. Esses dois √∫ltimos operadores s√£o is (√©) is not (n√£o s√£o).\nSeu primeiro instinto pode ser assumir que is e == s√£o as mesmas coisas, e o mesmo vale para is not e !=. Na verdade, eles s√£o muito diferentes e desempenham trabalhos muito diferentes.\nPrimeiro, vejamos um exemplo:\na = [1, 2, 3] b = [1, 2, 3] print(a == b) # True print(a is b) # False Aqui temos duas listas que cont√™m os mesmos valores. Portanto, podemos dizer que as listas s√£o as mesmas, e o operador == nos d√° True quando comparamos os dois. No entanto, o operador is nos d√° False.\nA raz√£o pela qual obtemos essa diferen√ßa √© porque, na verdade, estamos verificando se as duas listas s√£o exatamente a mesma lista. N√£o que tenham os mesmos valores, mas s√£o exatamente a mesma coisa.\nPara fazer uma analogia com o mundo real, podemos ter duas tigelas id√™nticas, cada uma contendo o mesmo arranjo de bolas coloridas. O operador == est√° verificando se as duas tigelas cont√™m o mesmo arranjo de bolas coloridas, enquanto is verifica se estamos falando exatamente da mesma tigela.\nQuando estamos falando sobre o que significa ser exatamente a mesma coisa em Python, o que realmente nos preocupa √© se as coisas que estamos comparando est√£o armazenadas no mesmo local na mem√≥ria.\nPodemos usar uma fun√ß√£o chamada id para descobrir onde algo est√° sendo armazenado, representado como uma longa s√©rie de n√∫meros. Essa longa s√©rie de n√∫meros √© um endere√ßo que faz refer√™ncia a um local na mem√≥ria. Podemos imprimir esses endere√ßos de mem√≥ria para verificar se as duas listas n√£o s√£o de fato iguais:\na = [1 ,2, 3] b = [1 ,2, 3] print(id(a)) # 2886424190912 print(id(b)) # 2886424190720 print(a == b) # True print(a is b) # False Voc√™ receber√° n√∫meros diferentes para cada lista, e n√∫meros diferentes toda vez que o programa for executado, mas o importante √© que os dois n√∫meros n√£o s√£o iguais.\nPodemos tornar as duas listas iguais fazendo uma pequena altera√ß√£o. Em vez de definir essa nova lista id√™ntica ao atribuir a b, vamos apenas nos referir √†quela que atribu√≠mos a a:\na = [1 ,2, 3] b = a print(id(a)) # 2886424195264 print(id(b)) # 2886424195264 print(a == b) # True print(a is b) # False Agora, ambos os nossos endere√ßos de mem√≥ria s√£o iguais e, como resultado, o operador is produz True quando comparamos a e b.\nOrdem das opera√ß√µes Uma nota final importante √© como esses operadores de compara√ß√£o interagem com os operadores aritm√©ticos que aprendemos anteriormente.\nOs operadores de compara√ß√£o sempre t√™m prioridade mais baixa do que os operadores aritm√©ticos. Por exemplo, se escrevermos uma express√£o como esta:\n5 + 4 \u0026lt; 3 * 2 Que nada mais √© que:\n(5 + 4) \u0026lt; (3 * 2) Que resulta em:\n9 \u0026lt; 6 #False Condicionais Agora que sabemos como usar esses operadores de compara√ß√£o, podemos usar os resultados dessas compara√ß√µes para controlar o fluxo de nosso aplicativo. Fazemos isso usando declara√ß√µes condicionais. A instru√ß√£o condicional mais b√°sica usa uma √∫nica palavra-chave: if (se).\nAs instru√ß√µes condicionais nos permitem executar algum bloco no c√≥digo se, e somente se, alguma condi√ß√£o for atendida. Podemos usar essa estrutura para controlar o fluxo de nosso aplicativo com base no fato de algo ser ou n√£o o caso. Por exemplo, s√≥ podemos permitir que um usu√°rio fa√ßa login em um site se ele inserir as credenciais corretas.\nVamos escrever um programa simples de barman. Vamos perguntar ao usu√°rio a idade dele e depois verificar se ele tem menos de 18 anos. Se eles s√£o menores de 18 anos, vamos publicar uma mensagem informando que eles s√£o menores de idade.\nidade = int(input(\u0026#34;Qual sua idade? \u0026#34;)) if idade \u0026lt; 18: print(\u0026#34;Desculpe, n√£o podemos te servir.\u0026#34;) Para a pr√≥pria condicional, come√ßamos com esta palavra-chave if, ent√£o temos alguma express√£o seguida por dois pontos. Abaixo desta linha, temos algum bloco de c√≥digo que queremos executar se a express√£o que escrevemos for avaliada como um valor verdadeiro.\nEste bloco de c√≥digo que queremos executar se a condi√ß√£o for atendida tem quatro espa√ßos de recuo no in√≠cio da linha. Este recuo √© muito importante. Se voc√™ n√£o fizer isso, o Python ir√° gerar uma exce√ß√£o.\nFile \u0026#34;main.py\u0026#34;, line 4 print(\u0026#34;Desculpe, n√£o podemos te servir.\u0026#34;) ^ IndentationError: expected an indented block A raz√£o pela qual precisamos de um recuo como este √© porque precisamos de alguma forma de sinalizar para o Python qual c√≥digo deve ser empacotado com essa condi√ß√£o. Tudo o que queremos que dependa dessa condi√ß√£o deve ser recuado para o mesmo n√≠vel de recuo.\nVamos expandir um pouco o nosso programa de barman. Depois de verificarmos que o usu√°rio tem de fato mais de 18 anos, quero poder solicitar ao usu√°rio a bebida de sua escolha.\nTemos outra palavra-chave condicional dispon√≠vel para n√≥s, chamada else (sen√£o), que nos permite fazer algo se a condi√ß√£o que estamos verificando n√£o for atendida. caso contr√°rio, n√£o pode ser usado sozinho e precisa ser anexado a outra estrutura. Nesse caso, estamos combinando-o com uma instru√ß√£o if, mas existem algumas outras op√ß√µes interessantes sobre as quais falaremos em postagens futuras.\nAqui est√° nosso programa atualizado:\nidade = int(input(\u0026#34;Qual sua idade? \u0026#34;)) if idade \u0026lt; 18: print(\u0026#34;Desculpe, n√£o podemos te servir.\u0026#34;) else: bebida = input(\u0026#34;O voc√™ gostaria de beber?\u0026#34;) Agora, se um usu√°rio tiver menos de 18 anos, ser√° informado de que n√£o podemos atend√™-lo, mas qualquer pessoa que inserir 18 ou mais no prompt inicial ser√° questionado sobre o que gostaria de beber.\nTamb√©m poder√≠amos escrever este bloco condicional assim:\nidade = int(input(\u0026#34;Qual sua idade? \u0026#34;)) if idade \u0026gt;= 18: bebida = input(\u0026#34;O voc√™ gostaria de beber?\u0026#34;) else: print(\u0026#34;Desculpe, n√£o podemos te servir.\u0026#34;) Agora estamos verificando a condi√ß√£o que permitiria ao usu√°rio prosseguir, o que √© mais comum.\n√Äs vezes, precisamos de mais granularidade do que isso; nesse caso, usar√≠amos uma cl√°usula elif. elif √© muito parecido com if em que precisamos especificar uma express√£o para testar. Bem como as outras coisas, ele n√£o pode existir por conta pr√≥pria: temos que combin√°-lo com uma instru√ß√£o if.\nQuando inclu√≠mos v√°rias condi√ß√µes como essa, o Python passar√° por nossas condi√ß√µes uma de cada vez, at√© que uma seja considerada verdadeira. Depois de encontrar uma condi√ß√£o verdadeira, ele executa o c√≥digo associado a essa condi√ß√£o, ap√≥s o qual nenhuma outra condi√ß√£o √© verificada para esta instru√ß√£o if. Se nenhuma das condi√ß√µes for verdadeira, o Python executa o c√≥digo recuado sob a cl√°usula else.\nO fato de que o Python n√£o verifica necessariamente todas as condi√ß√µes √© importante ter em mente por alguns motivos. Primeiro, significa que apenas o c√≥digo para uma condi√ß√£o ser√° executado. Em segundo lugar, significa que a ordem de nossas condi√ß√µes √© importante, j√° que o Python s√≥ executar√° o c√≥digo associado √† primeira condi√ß√£o correspondente.\nVamos dar uma olhada em uma cl√°usula elif em a√ß√£o mudando um pouco nosso exemplo. Mais uma vez, vamos perguntar a idade do usu√°rio, e dizer se ele √© eleg√≠vel a n√£o pagar a tarifa de onibus\nPodemos escrever algo assim:\nidade = int(input(\u0026#34;Qual sua idade? \u0026#34;)) if idade \u0026lt; 6: print(\u0026#34;Voc√™ √© uma crian√ßa de at√© 6 anos, n√£o paga a passagem.\u0026#34;) elif idade \u0026gt; 65: print(\u0026#34;Voc√™ √© um idoso maior de 65 anos, n√£o paga a passagem.\u0026#34;) else: print(\u0026#34;Voc√™ paga a passagem!\u0026#34;) Valores verdadeiros e condicionais N√£o estamos limitados a apenas usar operadores de compara√ß√£o com instru√ß√µes condicionais. Por exemplo, podemos usar o valor verdade de qualquer valor como uma condi√ß√£o. √â aqui que os valores verdadeiros se tornam realmente √∫teis, pois nos permitem fazer coisas como verificar sucintamente se uma cole√ß√£o est√° vazia.\nPor exemplo, podemos verificar se o usu√°rio realmente inseriu algo quando solicitamos alguma entrada:\nnome = input(\u0026#34;Qual o seu nome? \u0026#34;) if nome:\t# verifica se o usu√°rio digitou algo (booleano) print(f\u0026#34;Voc√™ digitou {nome}.\u0026#34;) else: print(\u0026#34;Voc√™ n√£o digitou nada!\u0026#34;) Analisaremos esse padr√£o nas pr√≥ximas aulas, ent√£o n√£o se preocupe se isso estiver um pouco confuso agora.\nExerc√≠cios   Crie duas vari√°veis, a atribua em cada uma delas seu primeiro nome de forma id√™ntica. Verifique se elas s√£o iguais (==) e se s√£o a mesma vari√°vel (is)\n  Solicite ao usu√°rio um n√∫mero. Retorne ao usu√°rio informando se o n√∫mero √© positivo, negativo ou zero.\n  Escreva um programa para determinar se um funcion√°rio deve fazer horas extras. Voc√™ deve perguntar ao usu√°rio quantas horas o funcion√°rio trabalhou nesta semana, bem como o sal√°rio por hora para este funcion√°rio.\nSe o funcion√°rio trabalhou mais de 40 horas, voc√™ deve imprimir uma mensagem informando que o funcion√°rio deve receber um pagamento adicional, bem como o valor devido. O valor adicional devido √© de 10% do sal√°rio-hora do empregado para cada hora trabalhada nas 40 horas. Com efeito, os funcion√°rios recebem 110% do seu sal√°rio por hora para qualquer hora extra.\n  "
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/",
	"title": "Basic√£o",
	"tags": [],
	"description": "",
	"content": "Cap√≠tulo 1 Basic√£o Vamos come√ßar a amolar o fac√£o!\n"
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula06/",
	"title": "6. La√ßos/Loops com For",
	"tags": [],
	"description": "",
	"content": " Por que precisamos dos loops? O que √© um loop for? Definindo um loop for Declarando uma parada com o break A fun√ß√£o range  Usando range em loops for   Importante Exerc√≠cios  Neste cap√≠tulo vamos falar sobre loops for, que nos permitir√£o repetir algumas a√ß√µes uma vez para cada item de uma cole√ß√£o(ex: lista).\nPor que precisamos dos loops? Vamos utilzar um exemplo anterior, onde definimos uma lista com tuplas para representar filmes de um cat√°logo.\nfilmes = [ ( \u0026#34;Tropa de Elite 2 - O Inimigo Agora √© Outro\u0026#34;, \u0026#34;Jos√© Padilha\u0026#34;, 2010 ), ( \u0026#34;Austin Powers 2\u0026#34;, \u0026#34;Jay Roach\u0026#34;, 1999 ), ( \u0026#34;O Auto da Compadecida\u0026#34;, \u0026#34;Guel Arraes\u0026#34;, 2000 )] Aqui temos uma lista chamada filmes, que cont√©m v√°rias tuplas. Essas tuplas cont√™m dados em uma ordem definida: o primeiro elemento em cada tupla √© o t√≠tulo do filme; o segundo elemento √© o diretor do filme; e o elemento final √© o ano de lan√ßamento.\nImagine que queremos imprimir o conte√∫do desta lista de filmes. Usando nosso conhecimento atual, podemos fazer algo assim:\nfilme = filmes[0] print(f\u0026#34;{filme[0]}({filme[2]}), por {filme[1]}\u0026#34;) filme = filmes[1] print(f\u0026#34;{filme[0]}({filme[2]}), por {filme[1]}\u0026#34;) filme = filmes[2] print(f\u0026#34;{filme[0]}({filme[2]}), por {filme[1]}\u0026#34;) O que imprimir√° na tela da seguinte forma:\nTropa de Elite 2 - O Inimigo Agora √© Outro (2010), por Jos√© Padilha Austin Powers 2 (1999), por Jay Roach O Auto da Compadecida (2000), por Guel Arraes Se quis√©ssemos ser um pouco mais sucintos, poder√≠amos deixar de lado as vari√°veis do filme e encadear v√°rias express√µes de assinatura:\nprint(f\u0026#34;{filmes[0][0]}({filmes[0][2]}), por {filmes[0][1]}\u0026#34;) print(f\u0026#34;{filmes[1][0]}({filmes[1][2]}), por {filmes[1][1]}\u0026#34;) print(f\u0026#34;{filmes[2][0]}({filmes[2][2]}), por {filmes[2][1]}\u0026#34;) Existem alguns problemas com o tipo de c√≥digo que escrevemos acima. Em primeiro lugar, temos muitos c√≥digos duplicados, o que torna este programa dif√≠cil de manter. Imagine se quis√©ssemos alterar a sa√≠da do programa deste:\nO Auto da Compadecida (2000), por Guel Arraes Para este:\nO Auto da Compadecida (2000) - Guel Arraes Temos que fazer essa mudan√ßa em 3 lugares diferentes. Mesmo com esse pequeno n√∫mero de filmes, √© muito f√°cil se perder um ou cometer um pequeno erro na formata√ß√£o, o que pode levar a diferen√ßas n√£o intencionais na sa√≠da de filme para filme.\nAgora imagine que temos 50 filmes. Ou 1.000 filmes. Nosso problema de manuten√ß√£o n√£o s√≥ ficou muito pior, como at√© escrever isso pela primeira vez ser√° um pesadelo.\nNosso c√≥digo tamb√©m √© muito fr√°gil. N√£o podemos contabilizar nenhuma altera√ß√£o na lista de filmes e precisamos saber com anteced√™ncia quantos filmes existem, para que possamos escrever um n√∫mero apropriado de chamadas da fun√ß√£o print.\nComo esse tipo de duplica√ß√£o de c√≥digo apresenta grandes desafios, as linguagens de programa√ß√£o modernas nos fornecem muitas ferramentas para remover esse tipo de duplica√ß√£o. Neste caso particular, a ferramenta que queremos √© um loop for.\nO que √© um loop for? Um loop for em Python √© um meio de realizar algum conjunto de opera√ß√µes para cada item em uma cole√ß√£o ou, mais geralmente, um iter√°vel. Em um sentido muito vago, podemos pensar em um iter√°vel como algo que √© capaz de nos dar valores um de cada vez, como uma lista, onde voc√™ pode percorr√™-la.\nNo caso de nosso exemplo de biblioteca de filmes, um loop for nos permitir√° obter itens da lista de filmes um de cada vez e executar uma a√ß√£o (ou s√©rie de a√ß√µes) para cada filme. Nesse caso, essa a√ß√£o √© imprimir o filme em algum formato espec√≠fico.\nAqui est√° um exemplo concreto de um loop para imprimir cada filme na lista de filmes no formato que usamos anteriormente:\nfilmes = [ ( \u0026#34;Tropa de Elite 2 - O Inimigo Agora √© Outro\u0026#34;, \u0026#34;Jos√© Padilha\u0026#34;, 2010 ), ( \u0026#34;Austin Powers 2\u0026#34;, \u0026#34;Jay Roach\u0026#34;, 1999 ), ( \u0026#34;O Auto da Compadecida\u0026#34;, \u0026#34;Guel Arraes\u0026#34;, 2000 )] for filme in filmes: print(f\u0026#34;{filme[0]}({filme[2]}), por {filme[1]}\u0026#34;) Como voc√™ pode ver, esse tipo de loop pode ser extremamente poderoso. A lista de filmes pode ter 10.000 filmes e conseguimos imprimi-los todos com apenas duas linhas de c√≥digo.\nDefinindo um loop for A defini√ß√£o do loop come√ßa com a palavra-chave for (para). Esta palavra-chave √© o que diz ao Python que queremos definir um loop for.\nLogo depois disso, temos um nome de vari√°vel, mas n√£o √© um nome que definimos em outro lugar em nosso c√≥digo. Voltaremos a isso em um momento.\nEm seguida, temos a palavra-chave in (em), seguida pelo iter√°vel (ex: lista) do qual queremos obter valores. Toda esta linha √© finalizada com dois pontos.\nIndentado abaixo do bloco est√° o c√≥digo que queremos executar para cada item em nosso iter√°vel. Assim como acontece com as instru√ß√µes condicionais, esse recuo √© importante, pois indica qual c√≥digo est√° associado ao loop for. Esse bloco recuado √†s vezes √© chamado de corpo do loop.\nOk, ent√£o o que est√° acontecendo com este nome, filme, em nosso exemplo? Na verdade, estamos definindo uma nova vari√°vel como parte do loop, e essa vari√°vel nos permitir√° referir-nos a um determinado valor em nosso iter√°vel.\nQuando executamos um loop for, come√ßamos a itera√ß√£o sobre o iter√°vel que fornecemos. Isso significa apenas que estamos obtendo valores do iter√°vel um de cada vez.\nQuando obtemos um novo valor de nosso iter√°vel, atribu√≠mos esse nome que definimos como parte do loop e, em seguida, executamos o c√≥digo no corpo do loop. Assim que terminarmos, pegamos um novo valor do iter√°vel, atribu√≠mos esse novo valor √† vari√°vel de loop e executamos o corpo do loop novamente com esse novo valor.\nQuando esgotamos os valores, o loop termina e passamos para qualquer c√≥digo que vier ap√≥s o loop.\nSe pensarmos sobre isso em termos de nosso exemplo de biblioteca de filmes, definiremos uma vari√°vel de loop chamada filme, e o iter√°vel do qual estamos pegando valores √© a lista de filmes.\nDurante a primeira itera√ß√£o (ciclo) do loop, pegamos o primeiro item dos filmes, que √© esta tupla:\n( \u0026#34;Tropa de Elite 2 - O Inimigo Agora √© Outro\u0026#34;, \u0026#34;Jos√© Padilha\u0026#34;, 2010 ) Essa tupla √© atribu√≠da ao filme e, em seguida, executamos o c√≥digo no corpo do loop. Temos apenas uma linha de c√≥digo no corpo, que se parece com isto:\nprint(f\u0026#34;{filme[0]}({filme[2]}), por {filme[1]}\u0026#34;) Como voc√™ pode ver, estamos nos referindo a esta vari√°vel filme aqui, portanto, nesta primeira itera√ß√£o do loop, filme[0] √© a string \u0026ldquo;Tropa de Elite 2 - O Inimigo Agora √© Outro\u0026quot;; filme[1] √© a string, \u0026ldquo;Jos√© Padilha\u0026quot;; e filme[2] √© o n√∫mero inteiro, 2010.\nAgora terminamos de executar o c√≥digo no corpo do loop, ent√£o tentamos obter outro valor de filmes. Como ainda temos filmes na lista, Python nos d√° a pr√≥xima tupla:\n( \u0026#34;Austin Powers 2\u0026#34;, \u0026#34;Jay Roach\u0026#34;, 1999 ) Essa nova tupla √© atribu√≠da ao filme, substituindo o valor antigo, e executamos o corpo do loop novamente.\nIsso acontece de novo e de novo at√© acabar a lista de filmes.\n√â importante ter em mente que o nome, filme, n√£o √© importante do ponto de vista da funcionalidade. Python n√£o est√° fazendo magicamente a conex√£o entre os nomes de filme e filmes. Poder√≠amos fazer qualquer um dos seguintes e funcionaria da mesma forma:\nfor f in filmes: print(f\u0026#34;{f[0]}({f[2]}), por {f[1]}\u0026#34;) for flm in filmes: print(f\u0026#34;{flm[0]}({flm[2]}), por {flm[1]}\u0026#34;) for detalhes_do_filme in filmes: print(f\u0026#34;{detalhes_do_filme[0]}({detalhes_do_filme[2]}), by {detalhes_do_filme[1]}\u0026#34;) √â apenas um nome de vari√°vel como qualquer outro que possamos definir.\nDeclarando uma parada com o break √Äs vezes, n√£o queremos iterar em uma cole√ß√£o inteira ou queremos parar o loop em certas circunst√¢ncias. Nesses casos, podemos usar uma instru√ß√£o chamada break.\nbreak √© geralmente usado em conjunto com uma instru√ß√£o condicional, porque caso contr√°rio, ele ser√° executado durante a primeira itera√ß√£o do loop, o que torna o loop basicamente discut√≠vel.\nUma maneira comum de usar uma instru√ß√£o break √© evitar opera√ß√µes desnecess√°rias. Por exemplo, digamos que queremos verificar se um determinado filme est√° na biblioteca de filmes a que sempre nos referimos.\nfilmes = [ ( \u0026#34;Tropa de Elite 2 - O Inimigo Agora √© Outro\u0026#34;, \u0026#34;Jos√© Padilha\u0026#34;, 2010 ), ( \u0026#34;Austin Powers 2\u0026#34;, \u0026#34;Jay Roach\u0026#34;, 1999 ), ( \u0026#34;O Auto da Compadecida\u0026#34;, \u0026#34;Guel Arraes\u0026#34;, 2000 )] for filme in filmes: # Verifique se o t√≠tulo do filme √© \u0026#34;O Auto da Compadecida\u0026#34; if filme[0] == \u0026#34;O Auto da Compadecida\u0026#34;: # Se o t√≠tulo \u0026#34;O Auto da Compadecida\u0026#34; for encontrado, informe o usu√°rio e pare o loop. print(\u0026#34;\u0026#39;O Auto da Compadecida\u0026#39; est√° no cat√°logo!\u0026#34;) break Nesse caso, tudo o que importa √© que o filme exista, ent√£o, se acabar sendo o primeiro item, n√£o h√° necessidade de ficarmos checando o resto. Se houver 10.000 filmes, n√≥s potencialmente nos salvamos verificando 9.999 filmes.\nLembre-se de que, para incluir a instru√ß√£o if dentro do loop for, ela precisa ser indentada com 4 espa√ßos. Portanto, o corpo da instru√ß√£o if precisa ser indentado com 8 espa√ßos para estar dentro do loope da instru√ß√£o if.\nIMPORTANTE: Os editores atuais permitem usar o TAB, que √© automaticamente formatado para 4 espa√ßos.\nA fun√ß√£o range Python tem uma fun√ß√£o interna chamada range (intervalo), que √© capaz de produzir uma s√©rie de inteiros de acordo com algum padr√£o definido. Por exemplo, podemos querer obter uma s√©rie de n√∫meros come√ßando em 1 e terminando em 100, movendo-se em etapas de 3. Nesse caso, ter√≠amos 1, 4, 7, 10, 13, 16, 19, etc.\nChamamos a fun√ß√£o rangeda mesma forma que fazemos para algo como imprimir (print) ou inserir (input), mas o range pode assumir um n√∫mero vari√°vel de valores.\nA maneira mais simples de definir um range √© fornecer o valor de parada para o intervalo:\nrange(10) Isso nos dar√° uma sequ√™ncia de inteiros come√ßando em zero e indo at√©, mas n√£o incluindo, o valor de parada. range(10), portanto, nos dar√° uma sequ√™ncia como esta:\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9 Como alternativa, podemos fornecer um valor inicial e um valor final. Nesse caso, o valor inicial vem primeiro e esse valor √© inclu√≠do no intervalo. range(10) √©, portanto, o mesmo que escrever range (0, 10).\nDigamos que queremos que nosso intervalo comece em 3 por algum motivo e que v√° at√©, mas n√£o incluindo 10. Definir√≠amos um intervalo assim:\nrange(3, 10) Que vai retornar os seguintes valores:\n3, 4, 5, 6, 7, 8, 9 Se especificarmos um valor inicial e um valor final, podemos opcionalmente especificar um valor de etapa. Por padr√£o, esse valor √© 1, o que significa que o pr√≥ximo n√∫mero na sequ√™ncia √© 1 maior do que o n√∫mero anterior.\nSe, em vez disso, quis√©ssemos obter todos os outros n√∫meros, poder√≠amos especificar uma etapa de 2. Se quis√©ssemos a cada tr√™s n√∫meros, especificar√≠amos uma etapa de 3.\nrange(0, 10, 2) # 0, 2, 4, 6, 8 range(0, 10, 3) # 0, 3, 6, 9 Tamb√©m podemos especificar um valor de passo negativo, o que significa que retrocedemos do valor inicial ao valor final.\nrange(10, 0, -1) # 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 Tenha cuidado, porque se especificarmos um intervalo onde n√£o podemos ir de um valor para outro, intervalo n√£o vai reclamar: ele apenas nos dar√° uma sequ√™ncia vazia. Por exemplo:\nrange(0, 10, -1) N√£o h√° como obtermos de 0 a 10 em etapas de -1, portanto, o intervalo n√£o nos d√° nada, em vez de uma cole√ß√£o infinita.\nUma coisa interessante sobre o range √© que ele √© um tipo lazy (pregui√ßoso). Isso significa que nosso intervalo n√£o cont√©m, na verdade, todos os valores nesta sequ√™ncia. Em vez disso, ele apenas descobre qual deve ser o pr√≥ximo n√∫mero quando o pedimos.\nIsso significa que se voc√™ tentar imprimir um intervalo, n√£o ver√° todos os valores:\nprint(range(1000)) #range(0, 1000) Tudo o que temos √© uma defini√ß√£o para o intervalo que geramos. Esse intervalo come√ßa em 0, vai para 1000 e usa um valor de etapa padr√£o. Isso torna o intervalo realmente eficiente em termos de mem√≥ria, porque ele n√£o precisa armazenar uma cole√ß√£o de potencialmente milh√µes de n√∫meros.\nrange √© iter√°vel, o que significa que podemos us√°-lo em loops for. Tamb√©m significa que podemos convert√™-lo em uma lista ou tupla, se quisermos.\nPodemos fazer isso usando as fun√ß√µes de lista (list) e tupla (tuple), assim como convertemos inteiros, flutuantes e strings usando int, float e str.\nnumeros = list(range(10)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numeros_imutaveis = tuple(range(10)) # (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) Usando range em loops for Uma coisa para a qual o intervalo √© realmente √∫til √© executar um loop um determinado n√∫mero de vezes.\nSe gerarmos um intervalo usando algo como intervalo (10), esse intervalo √© capaz de fornecer dez n√∫meros. Se iterarmos sobre essa cole√ß√£o, intervalo vai nos dar esses n√∫meros um de cada vez, e vamos executar o corpo do loop uma vez para cada n√∫mero.\nfor numero in range(10): print(numero) # 0 # 1 # 2 # ... # 9 Mesmo se n√£o usarmos o intervalo de n√∫meros gerado, ainda sabemos que obteremos dez itera√ß√µes do loop.\nPor exemplo, podemos imprimir uma determinada string dez vezes assim:\nfor numero in range(10): print(\u0026#34;Oi man√©!\u0026#34;) A sa√≠da ficar√° assim:\nOi man√©! Oi man√©! Oi man√©! Oi man√©! Oi man√©! Oi man√©! Oi man√©! Oi man√©! Oi man√©! Oi man√©! Quando escrevemos um loop como este, onde o n√∫mero que estamos gerando n√£o est√° sendo usado, √© uma conven√ß√£o comum nomear a vari√°vel do loop, _. Este √© um sinal claro para os leitores de nosso c√≥digo de que a vari√°vel de loop n√£o est√° presente em nosso corpo de loop.\nImportante √Äs vezes, voc√™ encontrar√° loops com _ como a vari√°vel de loop. Isso √© perfeitamente legal, porque _ √© um nome de vari√°vel v√°lido e, portanto, Python n√£o reclamar√°.\nEmbora seja legal, n√£o use _ no lugar de bons nomes descritivos. Ele serve a um prop√≥sito espec√≠fico, que √© indicar aos leitores que a vari√°vel de loop n√£o est√° realmente sendo usada no corpo do loop.\nUm bom momento para usar _ como uma vari√°vel de loop √© em situa√ß√µes como esta:\nfor _ in range(10): print(\u0026#34;Oi man√©!\u0026#34;) Aqui, estamos apenas usando o intervalo para garantir um certo n√∫mero de itera√ß√µes. Nunca nos referimos aos n√∫meros que o intervalo est√° gerando. Essa √© uma boa pr√°tica e muito √∫til para os leitores acostumados a essa conven√ß√£o de nomenclatura.\nNunca devemos usar _ em um loop como o mostrado abaixo:\nfor _ in range(10): print(_) Aqui estamos fazendo refer√™ncia _ dentro do corpo do loop, o que n√£o √© apenas muito feio, mas tamb√©m est√° desperdi√ßando a oportunidade de usar nomes bons e descritivos.\nExerc√≠cios   Abaixo est√° uma lista de tuplas, onde cada tupla cont√©m detalhes sobre um funcion√°rio de uma loja: seu nome, o n√∫mero de horas trabalhadas na semana passada e sua taxa hor√°ria. Imprima o quanto cada funcion√°rio deve receber no final da semana em um formato leg√≠vel.\nempregados = [ (\u0026#34;Jo√£o Almeida\u0026#34;, 35, 8.75), (\u0026#34;Adalberto Paiva\u0026#34;, 30, 12.50), (\u0026#34;Cleonice Silva\u0026#34;, 50, 15.50), (\u0026#34;Joaquim Silva\u0026#34;, 20, 7.00) ]   Para os funcion√°rios acima, imprima aqueles que est√£o ganhando um sal√°rio por hora acima da m√©dia.\nDica: voc√™ pode usar um loop for e duas vari√°veis para controlar o sal√°rio total e o n√∫mero de funcion√°rios. Em seguida, use as duas vari√°veis para calcular a m√©dia. Por fim, adicione outro loop que percorra a lista de funcion√°rios novamente e imprima apenas aqueles que t√™m uma remunera√ß√£o por hora acima da m√©dia calculada.\n  "
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/basicao/aula07/",
	"title": "7. La√ßos/Loops com While",
	"tags": [],
	"description": "",
	"content": " Loops infinitos  Dica   A palavra continue Usando else com loops Exerc√≠cios  Na √∫ltimo cap√≠tulo, demos uma olhada nos loops for como um meio de reduzir a repeti√ß√£o de c√≥digo. Os loops for s√£o √≥timos para dois tipos de a√ß√µes repetidas:\n  Quando queremos fazer algo para cada item em algum grupo.\n  Quando queremos fazer algo um determinado n√∫mero de vezes.\n  Existem, no entanto, outros tipos de repeti√ß√£o que podemos querer realizar. Por exemplo, e se quisermos realizar uma a√ß√£o quantas vezes forem necess√°rias at√© que alguma condi√ß√£o seja atendida? E se quisermos realizar alguma a√ß√£o repetidamente para sempre?\nPara esse tipo de a√ß√£o repetida, podemos usar um loop while.\nUm loop while √© um pouco mais simples do que um loop for. Precisamos apenas usar a palavra-chave while, seguida por alguma condi√ß√£o de teste. Se a condi√ß√£o for avaliada como um valor verdadeiro, o loop executar√° uma itera√ß√£o e, em seguida, testar√° a condi√ß√£o novamente.\nPor exemplo, podemos escrever um loop while que ser√° executado at√© que o usu√°rio insira um valor igual ou superior a 10.\nnumero_usuario = input(\u0026#34;Por favor digite um n√∫mero: \u0026#34;) while int(numero_usuario) \u0026lt; 10: print(\u0026#34;Seu n√∫mero √© menor que 10.\u0026#34;) numero_usuario = input(\u0026#34;Por favor escolha outro n√∫mero: \u0026#34;) print(\u0026#34;Seu n√∫mero √© igual ou maior a 10.\u0026#34;) Primeiro, solicitamos um n√∫mero inicial antes de iniciar o loop. Precisamos fazer isso, porque nos referimos ao nome numero_usuario como parte da condi√ß√£o do loop while, portanto, se n√£o definirmos esse nome de antem√£o, obteremos um NameError.\nMesmo se n√£o fosse o caso, ainda n√£o ter√≠amos um valor para numero_usuario, ent√£o o que estar√≠amos verificando?\nDepois que um usu√°rio insere um n√∫mero, atingimos a linha onde o loop while come√ßa. Verificamos a condi√ß√£o e, se ela for atendida, executaremos o corpo do loop uma vez. No caso acima, o corpo do loop ser√° executado se o usu√°rio inserir 9 ou menos.\nSe terminarmos dentro do corpo do loop, acabaremos imprimindo a mensagem sobre o n√∫mero ser menor que 10 e, em seguida, pediremos outro n√∫mero ao usu√°rio. Observe que atribu√≠mos esse novo valor a numero_usuario, o que significa que quando testamos a condi√ß√£o novamente, agora estamos testando um novo valor.\nSe nomearmos essa vari√°vel de outra forma, continuaremos verificando o valor original indefinidamente e, claro, nada mudar√° se o valor permanecer o mesmo. Isso pode nos levar a uma situa√ß√£o dif√≠cil, porque o loop vai acabar iterando infinitamente, e n√£o intencionalmente.\nQuando temos um loop while onde estamos verificando um valor como este, certifique-se de que podemos alterar o valor dentro do loop.\nLoops infinitos √Äs vezes, um loop infinito √© o que desejamos e h√° muitas maneiras de conseguir isso.\nMuito parecido com as instru√ß√µes condicionais, n√£o precisamos usar operadores de compara√ß√£o para nossa condi√ß√£o de loop: podemos apenas especificar um valor, e a veracidade desse valor determinar√° se o loop executa ou n√£o a pr√≥xima itera√ß√£o.\nNa verdade, podemos usar qualquer express√£o que quisermos, porque todas as express√µes ser√£o avaliadas para algum valor e, se obtivermos um valor, podemos testar seu valor verdadeiro. Podemos usar chamadas de fun√ß√£o ou opera√ß√µes aritm√©ticas, ou podemos nos referir a vari√°veis. O c√©u √© o limite.\nQuando queremos especificar um loop infinito, queremos escrever uma express√£o que sempre ser√° avaliada como um valor verdadeiro. Um bom exemplo √© o valor booleano True, que sempre ser√° avaliado como True se testarmos seu valor verdade.\nN√£o recomendo que voc√™ execute este c√≥digo, mas poder√≠amos escrever algo assim:\nwhile True: print(\u0026#34;Ol√° meu amigo!\u0026#34;) O que vai acontecer aqui √© que o Python executar√° muito rapidamente muitas itera√ß√µes desse loop e terminaremos com um fluxo constante de \u0026quot;Ol√° me amigo!\u0026quot; impresso no console.\nQuando escrevemos um loop explicitamente infinito como este, geralmente √© importante que tenhamos alguma maneira de interromp√™-lo, e isso √© mais frequentemente realizado com algum tipo de instru√ß√£o condicional em combina√ß√£o com break.\nComo exemplo, vamos criar o esqueleto de um menu de texto simples. Teremos algumas op√ß√µes que o usu√°rio pode selecionar e uma dessas op√ß√µes fechar√° o menu. Essa op√ß√£o ser√° a string \u0026quot;q\u0026quot;.\nwhile True: opcao = input(\u0026#34;Por favor, digite \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, ou \u0026#39;c\u0026#39;, ou digite \u0026#39;s\u0026#39; para sair: \u0026#34;) if opcao == \u0026#34;a\u0026#34;: print(\u0026#34;Voc√™ selecionou a op√ß√£o \u0026#39;a\u0026#39;!\u0026#34;) elif opcao == \u0026#34;b\u0026#34;: print(\u0026#34;Voc√™ selecionou a op√ß√£o \u0026#39;b\u0026#39;!\u0026#34;) elif opcao == \u0026#34;c\u0026#34;: print(\u0026#34;Voc√™ selecionou a op√ß√£o \u0026#39;c\u0026#39;!\u0026#34;) elif opcao == \u0026#34;q\u0026#34;: print(\u0026#34;Voc√™ selecionou a op√ß√£o \u0026#39;s\u0026#39;! Saindo do menu!\u0026#34;) break else: print(\u0026#34;Voc√™ digitou uma op√ß√£o inv√°lida\u0026#34;) Podemos imaginar que, em vez de simplesmente imprimir a sele√ß√£o do usu√°rio, cada uma dessas ramifica√ß√µes executaria algumas a√ß√µes em nome do usu√°rio e, quando terminarmos, solicitamos outra op√ß√£o ao usu√°rio.\nSe o usu√°rio inserir uma op√ß√£o inv√°lida, chegamos at√© o else e informamos o usu√°rio de seu erro.\nSe o usu√°rio digitar \u0026quot;s\u0026quot;, informamos ao usu√°rio que estamos fechando o menu e, em seguida, usamos uma instru√ß√£o break para sair do loop.\nObserve que, para este estilo de loop, n√£o precisamos definir nada fora do loop, porque n√£o temos uma condi√ß√£o que dependa de alguma vari√°vel.\nDica Se voc√™ come√ßar a olhar o c√≥digo de outras pessoas, poder√° ver alguns loops escritos como o abaixo, com 1 como a condi√ß√£o do loop:\nwhile 1: ... algumas a√ß√µes aqui ... Isso funciona porque 1 √© um valor verdadeiro, assim como todos os n√∫meros diferentes de zero. Embora funcione, eu pessoalmente desaconselho seu uso, pelo mesmo motivo, n√£o o aconselharia a escrever um loop como este:\nwhile \u0026#34;carneirinho\u0026#34;: Tanto 1 quanto \u0026quot;carneirinho\u0026quot; s√£o valores verdadeiros, mas s√£o muito menos expl√≠citos do que apenas escrever enquanto True. Ser expl√≠cito e tornar nosso c√≥digo o mais f√°cil de ler poss√≠vel √© mais importante do que economizar ao escrever tr√™s caracteres.\nA palavra continue J√° usamos a instru√ß√£o break v√°rias vezes, mas n√£o √© nossa √∫nica op√ß√£o para controlar o fluxo de nossos loops. Outra op√ß√£o que temos dispon√≠vel √© a palavra-chave continue.\nEnquanto break nos permite sair de um loop, continue nos permite pular o restante do corpo do loop para a itera√ß√£o atual.\nPor exemplo, vamos criar um loop que imprime apenas n√∫meros pares:\nfor numero in range(10): if numero % 2 != 0: ## Verifica se o resto da divis√£o por 2 √© diferente de 0. continue print(numero) Para cada itera√ß√£o do loop, usamos o operador m√≥dulo(%) para determinar se o n√∫mero atual √© divis√≠vel por 2. Se n√£o for, encontramos esta instru√ß√£o continue, que nos move imediatamente para a pr√≥xima itera√ß√£o do loop. Isso significa que pulamos o restante do corpo do loop e n√£o imprimimos o n√∫mero.\nA sa√≠da, portanto, ser√° semelhante a esta:\n0 2 4 6 8 Embora este exemplo use uma instru√ß√£o continue em um loop for, eles tamb√©m podem ser usados com loops while.\nAs declara√ß√µes continue geralmente n√£o s√£o t√£o √∫teis, mas de vez em quando elas podem realmente ajudar a simplificar o c√≥digo com condi√ß√µes complexas.\nUsando else com loops Na aula 5, demos uma olhada no else no contexto das declara√ß√µes condicionais, mas eu disse na √©poca que tamb√©m podemos usar o else com outras estruturas. loops for e while est√£o entre essas estruturas.\nA cl√°usula else no contexto de loops √© um pouco estranha e n√£o parece fazer muito sentido. Certamente n√£o √© t√£o intuitivo quanto √© com uma instru√ß√£o if. Acho que vale a pena pensar em outra coisa como uma cl√°usula \u0026ldquo;sem interrup√ß√£o\u0026rdquo; quando a usamos com loops.\nO motivo pelo qual digo que √© bom pensar em else como significando \u0026ldquo;sem interrup√ß√£o\u0026rdquo; √© porque uma cl√°usula else anexada a um loop s√≥ ser√° executada se uma instru√ß√£o break n√£o for encontrada durante a execu√ß√£o desse loop.\nPor exemplo, vamos escrever um loop para determinar se um n√∫mero √© primo ou n√£o. Um n√∫mero primo √© um n√∫mero divis√≠vel apenas por ele mesmo e 1. Por exemplo, 2, 3, 5, 7, 11 e 13 s√£o n√∫meros primos.\nUma maneira de determinar se algo √© primo ou n√£o √© dividindo-o por cada n√∫mero que vem antes dele. Se nenhuma dessas divis√µes produzir um resultado inteiro, sabemos que o n√∫mero √© primo.\nNo entanto, n√£o precisamos verificar todos os n√∫meros. Se encontrarmos uma divis√£o que produz um resultado inteiro, sabemos que o n√∫mero n√£o √© primo, ent√£o n√£o precisamos verificar mais. Podemos, portanto, quebrar o ciclo.\nSe quebrarmos sempre que descobrirmos que um n√∫mero n√£o √© primo, isso significa que se completarmos o loop e, portanto, n√£o encontrarmos uma instru√ß√£o break, teremos um n√∫mero primo. Essas tamb√©m s√£o as condi√ß√µes para acionar uma cl√°usula else.\n# Solicite um n√∫mero ao usu√°rio dividendo = int(input(\u0026#34;Por favor digite um n√∫mero: \u0026#34;)) # Cria um range de 2 at√© o n√∫mero escolhido e guarda em divisor for divisor in range(2, dividendo): # Se o n√∫mero usu√°rio escolhido for divis√≠vel (n√£o restar nada) por algum dos numeros da lista, o n√∫mero n√£o √© primo if dividendo % divisor == 0: print(f\u0026#34;{dividendo}n√£o √© primo!\u0026#34;) break else: # Essa linha apenas rodar√° se nenhum divisor produzir n√∫meros inteiros print(f\u0026#34;{dividendo}√© primo!\u0026#34;) Podemos fazer algo com o loop while tamb√©m:\n# Solicite um n√∫mero ao usu√°rio, e configure o divisor inicial em 2. dividendo = int(input(\u0026#34;Por favor digite um n√∫mero: \u0026#34;)) divisor = 2 # Continue repetindo at√© que o divisor seja igual ao n√∫mero que estamos testando while divisor \u0026lt; dividendo: # Se o n√∫mero for divisivel pelo divisor, quebra o loop if dividendo % divisor == 0: print(f\u0026#34;{dividendo}n√£o √© primo!\u0026#34;) break # Incrementa o divisor para a pr√≥xima itera√ß√£o divisor = divisor + 1 else: # Essa linha apenas rodar√° se nenhum divisor produzir n√∫meros inteiros print(f\u0026#34;{dividendo}√© primo!\u0026#34;) Existem maneiras mais sofisticadas de encontrar n√∫meros primos, mas elas servem muito bem como demonstra√ß√µes. Se voc√™ gostaria de um desafio, veja se pode torn√°-los mais eficientes.\nExerc√≠cios  Escreva um pequeno programa de jogo de adivinha√ß√£o usando um loop while. O usu√°rio deve ser solicitado a adivinhar um n√∫mero entre 1 e 100 e voc√™ deve dizer se a estimativa foi muito alta ou muito baixa ap√≥s cada estimativa. O loop deve continuar funcionando at√© que o usu√°rio adivinhe o n√∫mero corretamente. Usando um dos exemplos anteriores - ou uma solu√ß√£o inteiramente sua - crie um programa que imprima todos os n√∫meros primos entre 1 e 100.  "
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Python para todos Use a for√ßa C√≥digo √© poder, e aprender a programar lhe dar√° poder, e mudar√° a hist√≥ria da sua vida.\nAl√©m disso, quanto mais voc√™ entende o c√≥digo, mais entende o impacto que a tecnologia t√™m na vida das pessoas.\nPouco importa se esses impactos s√£o intencionais ou n√£o. Quando voc√™ constr√≥i uma plataforma que uma parte significativa da sociedade usa para comunica√ß√£o, por exemplo, seu c√≥digo tem impacto direto na pr√≥pria sociedade. Quando voc√™ escreve um c√≥digo que ajuda a determinar quem obt√©m um empr√©stimo, voc√™ influencia quem pode comprar uma casa.\nUse a for√ßa, mude sua hist√≥ria e a vida das pessoas na comunidade que voc√™ faz parte.\n"
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tiagotavares.io/content/pythonparatodos/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]